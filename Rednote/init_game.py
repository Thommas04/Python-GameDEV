# REDNOTE PROJECT 2022 - KOP / SK# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #from ursina import *from ursina.raycaster import raycastfrom os import *from random import *#from PIL import *from threading import *from pandas import DataFrame, read_excelfrom pathfinding.core.diagonal_movement import DiagonalMovementfrom pathfinding.core.grid import Gridfrom pathfinding.finder.a_star import AStarFinderfrom daylight_cycle import *from collisions import *from pause_menu import *from functions import *from objects import *from menu import Menufrom menu import *from hud import *from environment import *map = 'textures/seasons/map/rustfort_summer.png'# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #settings_file = fileread('settings/settings.rsp') # Megnyitni a settings fájlt.language = settings_file[0].split(':')[1] # kiolvasni a settings fájlból a beállított nyelvet.for file in os.listdir('./languages'):    exec('from languages.' + language + ' import *')    if file.endswith('.py'):        language_file = file.split('.')[0]        if language_file == language:            language_pack = set_language()# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #app = Ursina()window.color = rgb(16.065,32.895,28.05)window.vsync = Trueprint('vsync:',window.vsync)window.exit_button.enabled = Falseprint(settings_file[3].split(':')[1])if settings_file[3].split(':')[1] == "True":    window.fps_counter.x = -0.78    window.fps_counter.font = 'fonts/pricedown.otf'    window.fps_counter.color = rgb(255, 163, 57)    window.fps_counter.alpha = 0.5else:    window.fps_counter.disable()camera.color = color.red#create_net()#background = Entity(model = 'cube', collider = 'box', scale = (1000,1000,0), color = color.dark_gray, position = (0,0,0.1))# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #class Matrix:    def __init__(self, size_x, size_y):        self.size_x = size_x        self.size_y = size_y        self.updated_tiles = [] # Ide kerülnek azok a koordináták, melyek legutóbb frissítve lettek.        self.matrix = [[{'reserved' : False,                         'type' : None                         } for x in range(size_x)] for y in range(size_y)]        self.info_dict = {}    def get_value(self, x, y, key_word): # visszaadja az adott terület értékét        return self.matrix[self.size_y - y][x][key_word]    def set_value(self, x, y, key_word, value): # adott területre értéket állít        self.matrix[self.size_y - y][x][key_word] = value    def print_matrix(self): # printeli a mátrixot        for x in self.matrix:            print(f'{x}')# ----------------------------------------------------------------------------------------------------------------------matrix = Matrix(size_x = 200, size_y = 200)matrix.set_value(3, 4, 'type', 'grass')matrix.set_value(0, 1, 'type', 'nullanulla')matrix.set_value(1, 1, 'type', 'egynul')matrix.set_value(0, 1, 'type', 'nulegy')matrix.set_value(9, 9, 'type', 'kilkil')matrix.set_value(8, 9, 'type', 'nyolckil')print(matrix.get_value(3, 4, 'type'))# ----------------------------------------------------------------------------------------------------------------------#####alma = 'kocogtee'#####matrix_data_frame = new_tile_excel(matrix.size_x, matrix.size_y)#matrix_info_frame = new_info_excel()#rawsave_excel(matrix_info_frame,"saves/kiskocog/info_data.xlsx" , 'infoset')#####rawsave_excel(matrix_data_frame,f"saves/{alma}/tile_data.xlsx" , 'tileset')# Csak akkor tudok read_excelt használni ha már létezik a fájl#matrix_data_frame = read_excel(f"saves/{alma}/tile_data.xlsx", sheet_name = 'tileset') # beolvas#matrix_info_frame = read_excel("saves/kiskocog/info_data.xlsx", sheet_name = 'infoset') # beolvas#load_info_from_excel(matrix = matrix, data_frame = matrix_info_frame)#load_from_excel(data_frame = matrix_data_frame, matrix = matrix, excel_path ="saves/matrix.xlsx")#############################################################################################################################load_to_excel(data_frame = matrix_data_frame, matrix = matrix, excel_path = f"saves/{alma}/tile_data.xlsx", sheet = 'tileset')##matrix.set_value(2, 9, 'type', 'kekcske')##matrix.set_value(2, 10, 'type', 'béka')##matrix.set_value(2, 11, 'type', 'elment')##matrix.set_value(2, 12, 'type', 'nyaralni')##matrix.updated_tiles = [[2,9],[2,10],[2,11],[2,12]]##fast_load_to_excel(matrix_data_frame, matrix, "saves/kiskocog/tile_data.xlsx", 'tileset')##matrix.print_matrix()##print('faszomat: ',matrix.get_value(2, 11, 'type'))##place_objects_from_matrix(matrix)# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #def collison_hit():    passec = 1 # korrekciós célokraclass Player(Entity):    def __init__(self, x, y, invincibility = False,  **kwargs):        super().__init__(self, **kwargs)        self.model = 'quad'        self.scale = (1, 1, -1)        self.rotation = (90, 0, 0)        self.position = [x, y - ec, -0.1]        self.tag = 'player'        self.alpha = 0        self.invincibility = invincibility        self.amount_of_tower = 0        # -=============================================================================================================        self.pause_menu_state = None        self.state = 'inmenu'  # ingame / inmenu        self.tutorial_needed = False        self.current_active_marker = None # tartalmazza, hogy milyen típusú markerban van benne.        # LOAD WORLD SETTINGS        self.cheats = False        self.alive = True        self.right_hand = 'hand' # Tartalmazza, hogy mi van a játékos jobb kezében.        self.inventory_open = False        self.shop_open = False        self.builder_mode = False        self.towers_list = []        # INTERIOR        self.markers_list = []        self.interior_exit_enable_byte = True        #LIGHTS        self.lights_list = []        #TREES        self.trees_list = []        #BUILDINGS - INTERACTIVE LAYERS        self.building_layers_list = []        # ENEMY & RAIDS        self.raid_attack = False        self.enemies = []        self.existing_enemy = 0        self.enemy_alive = 0        self.wave_amount = 0        self.current_wave = 1        #INTERACTIVE OBJECTS        self.interactive_object_list = []        # -=============================================================================================================        self.player_stats = {'health': 100,                             'energy': 100,                             'hunger': 100,                             'thirst': 100,                             'power' : 100,                             'health_core' : 50,                             'energy_core': 50,                             'hunger_core': 50,                             'thirst_core': 50,                             'power_core': 50,                             'wallet_balance' : 52,                             'bank_balance': 565,                            }        self.directions = ['no_up','no_left','no_down','no_right']        self.right_det = Entity(model='plane', scale=(0.2, 0.5, -0.5), position=(self.position.x + 0.6, self.position.y - 1.25 + ec, -0.1), color=color.red, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=True)        self.left_det = Entity(model='plane', scale=(0.2, 0.5, -0.5), position=(self.position.x - 0.6, self.position.y - 1.25 + ec, -0.1), color=color.brown, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=True)        self.up_det = Entity(model='plane', scale=(1, 1, -0.2), position=(self.position.x, self.position.y - 0.9 + ec, -0.1), color=color.azure, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=True)        self.down_det = Entity(model='plane', scale=(1, 1, -0.2), position=(self.position.x, self.position.y - 1.6 + ec, -0.1), color=color.pink, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=True)        self.shot_bullet_list = []        self.player_graphics = SpriteSheetAnimation('textures/main_character/main_character_spritesheet.png', position=[x, y, -0.15], alpha = 1, tileset_size=(30, 4), scale = (2.25,3.625) ,fps=30, animations={            'idle_up': ((0, 1), (0, 1)),            'idle_right': ((0, 2), (0, 2)),            'idle_left': ((0, 3), (0, 3)),            'idle_down': ((0, 0), (0, 0)),            'walk_up': ((0, 1), (29, 1)),            'walk_right': ((0, 2), (29, 2)),            'walk_left': ((0, 3), (29, 3)),            'walk_down': ((0, 0), (29, 0)),        })        self.player_parts = [self,self.right_det, self.left_det, self.up_det, self.down_det, self.player_graphics]    def update(self):        global movespeed, energy_core_action_enabled        if self.state == 'ingame' and paused == False and player.builder_mode == False and self.shop_open == False:            right_hit = self.right_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            left_hit = self.left_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            up_hit = self.up_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            down_hit = self.down_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            # ----------------------------------------------------------------------------------------------------------            # PLAYER AND OBJECT MANAGEMENT            for layer in self.building_layers_list: #TODO                if distance_2d((layer.x, layer.y), (self.x, self.y)) <= layer.tag[1]:                    if layer.position.y + layer.tag[0] <= self.position.y: #objektum mögött tartózkodik                        self.player_graphics.position = [self.player_graphics.position.x, self.player_graphics.y, -0.12]                    else:                        self.player_graphics.position = [ self.player_graphics.position.x, self.player_graphics.y, -0.15]            for interactive in self.interactive_object_list: #TODO                if distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)) <= 3.5:                    if interactive.object.position.y <= self.position.y: #objektum mögött tartózkodik                        self.player_graphics.position = [self.player_graphics.position.x, self.player_graphics.y, -0.12]                    else:                        self.player_graphics.position = [ self.player_graphics.position.x, self.player_graphics.y, -0.35]            # ------------------------------------------------------------------------------------------------------------------------------            if not held_keys['right mouse']:                if not shoot and held_keys['shift']:                    if player.player_stats['energy_core'] >= 1:                        movespeed = 4                        if energy_core_action_enabled == True:                            if held_keys['w'] or held_keys['a'] or held_keys['s'] or held_keys['d']:                                invoke(player_energy_core_action, -2, 'reduce', delay = 0.6)                                energy_core_action_enabled = False                else:                    movespeed = 2.5            # [] ---------------------------------------------------------------------------------------------------------------------------            if right_hit.hit == False:                for parts in self.player_parts:                    parts.x += held_keys['d'] * movespeed * time.dt            else: collison_hit()            if left_hit.hit == False:                for parts in self.player_parts:                    parts.x -= held_keys['a'] * movespeed * time.dt            else: collison_hit()            if up_hit.hit == False:                for parts in self.player_parts:                    parts.y += held_keys['w'] * movespeed * time.dt            else: collison_hit()            if down_hit.hit == False:                for parts in self.player_parts:                    parts.y -= held_keys['s'] * movespeed * time.dt            else: collison_hit()            # ----------------------------------------------------------------------------------------------------------            # INTERIOR HANDLING            for marker in self.markers_list:                if marker.type_ == 'interior_marker':                    if self.interior_exit_enable_byte == True:                        if distance(self.position, marker.intexit) < 1:                            Interior.load_interior(marker)                            self.interior_exit_enable_byte = False                    if distance(self.position, marker.intexit) > 1 and distance(self.position, marker.intexit) < 2 :                        self.interior_exit_enable_byte = True                if marker.type_ == 'shop_marker':                    if distance_2d((marker.shop_marker.position.x, marker.shop_marker.position.y),(self.position.x, self.position.y)) <= 4:                        hud.show_instruction_slots(marker.type_)                    else:                        hud.hide_instruction_slots()                self.current_active_marker = marker.type_    # ------------------------------------------------------------------------------------------------------------------    # A FŐ KARAKTER SÉTÁLÁSÁNAK ANIMÁLÁSA    def input(self, key):        if self.state == 'ingame' and paused == False and player.builder_mode == False and self.shop_open == False:            if key == 'w':                self.directions[0] = 'up'                self.player_graphics.play_animation('walk_up')            elif key == 's':                self.directions[2] = 'down'                self.player_graphics.play_animation('walk_down')            elif key == 'a':                self.directions[1] = 'left'                self.player_graphics.play_animation('walk_left')            elif key == 'd':                self.directions[3] = 'right'                self.player_graphics.play_animation('walk_right')            # --------------------------------------------------------------------------------------------------------------            if key == 's up':                                                               # ha [s] felenged                self.directions[2] = 'no_down'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_down')            if key == 'a up':  # ha [a] felenged                self.directions[1] = 'no_left'                if self.directions[2] == 'down' : #                                         de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[0] == 'up' :                                           # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_left')            if key == 'd up': # ha [d] felenged                self.directions[3] = 'no_right'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_right')            if key == 'w up': # ha [w] felenged                self.directions[0] = 'no_up'                if self.directions[1] == 'left' :                                           # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_up')######################################################################################################################## [ Place Class ] ###################################################################################################towers = [] # tartalmazza az összes tornyotclass Tower(Entity): # torony    def __init__(self, tag, x, y, hp, let_shoot, target, unbreakable, brokable_with, **kwargs):        global towers        super().__init__(self, **kwargs)        self.global_time = 0        self.last_time = 0        self.x = x        self.y = y        self.model = 'quad'        self.color = color.violet        self.position = (self.x, self.y, -0.1)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.scale = (3, 3, 0)        self.hp = hp        self.target = target # ellenség vagy a játékos a cél        self.let_shoot = let_shoot # lőhet-e, ez tornyok esetében jelentős        self.unbreakable = unbreakable # törhetetlen-e vagy sem - True / False        self.brokable_with = brokable_with # kitörhető valamilyen tárggyal a kézben, ez egy list is lehet.        self.shoot_cooldown = True        self.tower_bullets = []  # tartalmazza a kilőtt golyókat        towers.append(self)    def update(self):        if player.state == 'ingame' and paused == False and player.builder_mode == False:            if self.let_shoot == True:                self.global_time += time.dt                if self.global_time - self.last_time > (randint(100, 150) / 100):  # random időközönként ad engedélyt                    self.last_time = self.global_time                    self.shoot_cooldown = True                for enemy in player.enemies:                    if enemy.alive:                        if distance([enemy.x, enemy.y, 0],[self.x, self.y, 0]) <= 15:                            if self.shoot_cooldown == True:                                tower_bullet = Entity(parent = scene, model = 'sphere',                                                      color = color.red, position = self.world_position, tag = 'tower_bullet',                                                      scale = (0.2, 0.2, 0.05))                                self.tower_bullets.append(tower_bullet)                                if self.target == 'enemy':                                    tower_bullet.look_at_2d(Vec3(enemy.world_position))                            self.shoot_cooldown = False                    #[] -----------------\\\///-------[]                    for bullet in self.tower_bullets:                        if enemy.alive == True:                            if distance(enemy, bullet) <= 1:                                self.tower_bullets.remove(bullet)                                destroy(bullet)                                enemy.color = color.black                                enemy.alive = False                                enemy.collider = None                                print('torony ellenségett lőtt')                        elif distance(enemy, bullet) > 20:                            destroy(bullet)                            self.tower_bullets.remove(bullet)                for bullet in self.tower_bullets:                    bullet.world_position += bullet.up * 85 * time.dt                    bullet_det = bullet.intersects(debug = False, ignore = (bullet))######################################################################################################################## [ SPAWNER Class ] ###################################################################################################raider_sheet = 'textures/enemy/raider/raider.png'class Spawner(Entity): # includes enemies ; npc-s    def __init__(self, tag, x, y, hp, list, ammo, let_shoot, let_move, invincible, **kwargs):        super().__init__(self, **kwargs)        self.global_time = 0  #        self.last_time = 0        self.global_time_reload = 0  #        self.last_time_reload = 0        self.x = x        self.y = y        self.model = 'quad'        self.scale = (0.55,0.38,0)        self.position = (self.x, self.y, -0.1)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.alpha = 0        self.speed = (randint(60, 100) / 100)        self.hover_z = (randint(121, 530) / 1000) * -1        player.enemies.append(self)        player.existing_enemy += 1        player.enemy_alive += 1        self.stay_attack_distance = randint(1500,2500) / 100        ##################################################x        self.body_texture = Entity(texture = raider_sheet, model = 'quad', position = (self.x, self.y, -0.1), scale = (1.65,1.14,0), alpha = 1)        # A lista tartalmazza az enemy layerjeit.        self.texture_list = [self, self.body_texture]        ##################################################x        self.list = list # a lista, amiben mozoghat        self.current_move = 0 # a jelenlegi állása a listában        self.invincible = invincible        self.alive = True        self.hp = hp        self.reload_enable = False # engedély újratöltésre - True ha üres a tár.        self.reloaded = False # Újratöltés befejezve. < késleltetve >        self.shot_bullet = [] # tartalmazza a kilőtt golyókat        self.shoot_directed = False  # True, ha a golyó kapott irányt.        self.shoot_delayed = False        self.full_ammo = ammo        self.loaded_ammo = 6        self.now_you_see_me = False # True ha a játékos a látóterében van, és nem takarja semmilyen fal.        self.let_shoot = let_shoot        self.scale = (1, 1, 0)        self.let_move = let_move    # []//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]    def update(self):        if player.state == 'ingame' and paused == False and player.builder_mode == False:            self.global_time += time.dt            if self.global_time - self.last_time > (randint(100,200) / 100):  # random időközönként ad engedélyt                self.last_time = self.global_time                self.shoot_delayed = True            if self.full_ammo != 0:                if self.reload_enable == True:                    self.global_time_reload += time.dt                    self.reload_enable = False                    if self.global_time_reload - self.last_time_reload > 3:  # random időközönként ad engedélyt                        self.last_time_reload = self.global_time_reload                        self.shoot_delayed_reload = True                        self.reloaded = True            #[]//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]            if self.alive:                if self.let_move == True:                    try:                        self.look_at_2d(Vec3(self.list[self.current_move][0], self.list[self.current_move][1], self.position.z))                    except: pass                    if distance(self, player) >= self.stay_attack_distance:                        if distance(self.position,self.list[-1]) >= 0.1:                            if self.current_move != len(self.list): # amíg a current_move nem egyenlő a lista hosszával                                for part in self.texture_list: # Végigjárja a listát, ami tartalmazza az enemy layerjeit.                                    part.position += self.up * time.dt * self.speed * 4# mozgatás                                if self.current_move != len(self.list) - 1:                                    if round(self.position.x, 1) == round(float(self.list[self.current_move][0]),1): # ellenőrzi hogy elérte e a pozíciót.                                        if round(self.position.y, 1) == round(float(self.list[self.current_move][1]),1):                                            self.current_move += 1 # tovább lép a következő pontra.              #[]------------------------------------------------------------------------------------------------------------[]                # az ellenségek lövése és köztes akadályok ellenőrzése #####################################                if self.let_shoot == True: # ha az adott enemy számára a lövés engedélyezve van.                    if distance((player.x,0,0), (self.x,0,0)) <= 17.5 and distance((0,player.y,0), (0,self.y,0)) <= 11:  # lőtávolság                        obstacle_test = raycast(self.world_position,                                                direction = player.world_position - self.world_position,                                                distance = distance(player.world_position, self), traverse_target = scene, ignore = [self], debug = True)                        if obstacle_test.hit: # felsorolt elemeken keresztül nem lőhet rád az enemy                            if obstacle_test.entity.tag == 'enemy' or obstacle_test.entity.tag == 'building' or obstacle_test.entity.tag == 'tower' or obstacle_test.entity.tag == 'tree':                                self.now_you_see_me = False                            else:                                self.now_you_see_me = True                    else:                        self.now_you_see_me = False                    if self.now_you_see_me == True: # ha az enemy látja a játékost.                        if self.loaded_ammo != 0:                            if self.shoot_delayed == True:                                self.shoot_delayed = False                                enemy_bullet = Entity(parent=scene, model='sphere', collider='box',                                                      color=color.red, position = self.world_position, tag = 'enemy_bullet', scale = (0.2, 0.2, 0.05))                                enemy_bullet.look_at_2d(Vec3(player.world_position))                                self.shot_bullet.append(enemy_bullet)                                self.loaded_ammo -= 1                                #print(self.loaded_ammo)                        if self.loaded_ammo == 0:                            self.reload_enable = True # Várnia kell 3 másodpercet míg újratölt                            if self.full_ammo != 0:                                a = 6                                if self.full_ammo < 8: # ha kevesebb mint 8 tölténye maradt, akkor csak annyit tölthessen vissza.                                    a = self.full_ammo                                if self.reloaded == True:                                    for i in range(a - self.loaded_ammo):                                        if self.full_ammo > 0:                                            self.full_ammo -= 1                                            self.loaded_ammo += 1  # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                                    #print('ammo:',self.full_ammo)            #[]--------------------------------------------------------------------------------------------------------[]            for bullet in self.shot_bullet:                bullet.world_position += bullet.up * 80 * time.dt  # a hányados takarja a sebességét a golyónak                if distance(player, bullet) <= 1:                    self.shot_bullet.remove(bullet)                    player_got_shot()                    destroy(bullet)                elif distance(player, bullet) > 20:                    self.shot_bullet.remove(bullet)                    destroy(bullet)# []-----------------------------------------------------------------------------------------------------------------[]#____________________________________________________________________________________________________________________## [ CONSTANTS ] ######################################################################################################movement_dict = {    'enemy_move_0' : [[4.6,18.8,-0.1], [13.9,25.8,-0.1], [33.5,26.9,-0.1], [46.0,34.8,-0.1], [69.1,38.0,-0.1], [72.8,48.1,-0.1], [70.0,59.4,-0.1], [63.8,64.1,-0.1], [64.6,77.2,-0.1], [65.3,97.2,-0.1], [66.5,114.1,-0.1], [74.2,118.0,-0.1], [83.4,118.6,-0.1], [104.7,119.2,-0.1]],    'enemy_move_1' : [[0.2,19.7,-0.1], [18.0,28.3,-0.1], [48.5,36.8,-0.1], [61.8,39.3,-0.1], [85.6,118.1,-0.1]],    'enemy_move_2' : [[0.7,20.4,-0.1], [17.3,39.9,-0.1], [27.7,55.4,-0.1], [46.7,59.4,-0.1], [50.7,59.4,-0.1], [53.7,62.4,-0.1], [64.2,63.5,-0.1], [64.6,79.1,-0.1], [85.5,112.4,-0.1]],    'enemy_move_3' : [[2.3,12.7,-0.1], [64.1,58.7,-0.1], [68.9,137.1,-0.1], [110.3,123.6,-0.1]],}class Attack(): # hullámok TODO    def __init__(self):        global difficulty_        self.inside_enemies = []        difficulty_ = None    def attack_management(self, time):        if time == 365:            self.start_attack(x = -10, y = -10, difficulty = 10, wave_amount = 5, hp = 100, ammo = 100, delay = 2)    def start_attack(self, x, y, difficulty, wave_amount, hp = 50, delay = 0, ammo = 100):        global difficulty_, x_, y_, hp_, ammo_        # LEFUT MINDEN ESETBEN HA ELKEZDŐDIK EGY ROHAM        x_ = x ; y_ = y ; hp_ = hp ; ammo_ = ammo        player.raid_attack = True        player.wave_amount = wave_amount        player.current_wave = 1        hud.show_attack_hud()        difficulty_ = difficulty        for i in range(difficulty * 2):            self.create_enemies = Spawner(tag = 'enemy', x = x + (randint(-50, 50) / 10) , y = y + (randint(-50, 50) / 10), hp = hp, ammo = ammo, list = movement_dict['enemy_move_' + str(randint(0, len(movement_dict) - 1))], let_shoot = True, let_move = True, invincible = False)            self.inside_enemies.append(self.create_enemies)    # ----------------------------------------------------------------------- []    def start_next_wave(self):        global difficulty_        player.current_wave += 1        player.existing_enemy = 0        for i in range(difficulty_ * 2):            self.create_enemies = Spawner(tag='enemy', x=x_ + (randint(-50, 50) / 10), y=y_ + (randint(-50, 50) / 10), hp=hp_, ammo=ammo_, list=movement_dict['enemy_move_' + str(randint(0, len(movement_dict) - 1))], let_shoot=True, let_move=True, invincible=False)            self.inside_enemies.append(self.create_enemies)    # ----------------------------------------------------------------------- []    def victory(self):        player.existing_enemy = 0        player.enemy_alive = 0        player.wave_amount = 0        player.current_wave = 0        print("győzelem")        player.raid_attack = False        hud.hide_attack_hud()        player.player_stats['bank_balance'] += randint(100, 300)    # ----------------------------------------------------------------------- []    def defeat(self): # Ha a játékos meghal        player.existing_enemy = 0        player.enemy_alive = 0        player.wave_amount = 0        player.current_wave = 0        player.raid_attack = False        hud.hide_attack_hud()        for enemy in self.inside_enemies:            for enemy_bullet in enemy.shot_bullet:                destroy(enemy_bullet)            player.enemies.remove(enemy)            destroy(enemy.body_texture)            destroy(enemy)        player.player_stats['bank_balance'] -= randint(100,200)        player.player_stats['wallet_balance'] = 0#########################################################################################################################tower01 = Tower(tag = 'tower', x = 10,y = 10, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower02 = Tower(tag = 'tower', x = 5, y = 8,  hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower03 = Tower(tag = 'tower', x = 13,y = -3, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])########################################################################################################################full_ammo = 500 # bulletrevolver_ammo = 6 # bulletrevolver_shoot_speed = 0.2 # secpull_up = Trueshoot = Falsedef pull_up_delay():    global pull_up    if pull_up == False:        pull_up = True# [] ------------------------------------------------------------------------------------------------------------------[]def enemy_shot():    #ray.entity.disable() ---- del enemies[enemies.index(ray.entity)] #törli az adott entityt a listából    if not ray.entity.invincible:        ray.entity.alive = True        ray.entity.color = color.red# [] ------------------------------------------------------------------------------------------------------------------[]def player_got_shot(): # Meglőtték a játékost    global elapsed_time_player_got_shot    if player.invincibility == False:        player_health_core_action(randint(1,5), 'reduce')        elapsed_time_player_got_shot = 0# [] ------------ []def relocate(entity, x, y): # A* movement    grid = Grid(matrix=matrix.matrix)    start = grid.node(int(entity.x), int(entity.y))    end = grid.node(x, y)    finder = AStarFinder()    path, runs = finder.find_path(start, end, grid)    list_path = []    for i in range(len(path)):        list_path.append([path[i][0], path[i][1],0])    return list_path# [] ------------------------------------------------------------------------------------------------------------------[]pmenu_open = Falseweapon_wheel_open = Falselock_pausemenu = Falselock_swing_axe = Falsedef enable_pausemenu():    global lock_pausemenu    lock_pausemenu = Falsedef enable_swing_axe():    global lock_swing_axe    lock_swing_axe = False#----------------------------------#paused = Falsedef input(key):    global paused, lock_pausemenu, weapon_wheel_open, lock_swing_axe, follow_script    if player.state == 'ingame' and weapon_wheel_open == False and paused == False:        if player.alive == True:            if key == 'left mouse down':                print('jesuska')                if player.builder_mode == True:                    print('helloka')                    if player.amount_of_tower >= 1:                        print('kell torony')                        tower = Tower(tag = 'tower', x = mouse.world_point.x, y = mouse.world_point.y, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])                        player.towers_list.append(tower)                give_back_clicked_pos() # szedd ki ha vége a fejlesztésnek                #pass #enemy01.list = relocate(enemy01, 5, 5)            # ----------------------------------------------------------------------------------------------------------            # INSTRUCTION BUTTONS            #print(player.current_active_marker)            if player.current_active_marker == 'shop_marker':                if key == 'q': # BUY                    if player.inventory_open == False and player.shop_open == False:                        player.shop_open = True                        hud.show_shop()                        hud.hide_hud()                        hud.hide_ammo_text()                        hud.show_money_text(player.player_stats['bank_balance'], player.player_stats['wallet_balance'])                        hud.hide_attack_hud()                if key == 'e': # SELL                    print('sell')                    if player.inventory_open == False and player.shop_open == False:                        player.shop_open = True                        inventory.show_inventory(x = -0.8, mode = 'sell')                        hud.hide_hud()                        hud.hide_ammo_text()                        hud.show_money_text(player.player_stats['bank_balance'],player.player_stats['wallet_balance'])                        hud.hide_attack_hud()            # ----------------------------------------------------------------------------------------------------------            global pull_up, revolver_ammo, full_ammo, bullet, ray, pmenu_open            if player.right_hand == 'colt':                if key == 'left mouse down' and player.inventory_open == False and player.shop_open == False:                    if pull_up == True and revolver_ammo > 0:                        if mouse.world_point:                            if shoot == True: # Ha a karakter céloz, mikozbe lő                                direction = mouse.world_point.x, mouse.world_point.y, 0                            if shoot == False: # Ha a karakter nem céloz - eredmény hogy nagyobb a szóras                                direction = mouse.world_point.x + (randint(-300, 300) / 100), mouse.world_point.y + (randint(-500, 500) / 100), 0                            bullet = Entity(parent = scene, model = 'sphere', color = color.black, position = player.position, tag ='projectile', scale = (0.2, 0.2, 0.2))                            bullet.look_at_2d(Vec3(direction))                            player.shot_bullet_list.append(bullet)                            pull_up = False                            revolver_ammo -= 1                            invoke(pull_up_delay, delay = revolver_shoot_speed)            # -------------------------------------------------------------------------                    if player.inventory_open == False:                        hud.show_ammo_text(revolver_ammo, full_ammo)                if key == 'r': # reload                    for i in range(6 - revolver_ammo):                        if full_ammo > 0:                            full_ammo -= 1                            revolver_ammo += 1 # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                    if player.inventory_open == False and player.shop_open == False and player.builder_mode == False:                        hud.show_ammo_text(revolver_ammo, full_ammo)            # ----------------------------------------------------------------------------------------------------------            # CUTTING THE TREES            if player.right_hand == 'axe':                if lock_swing_axe == False:                    if key == 'left mouse down':                        for tree in player.trees_list:                            if distance(player.position, tree.pos) <= 2:                                if tree.mouse_on == True and tree.health >= 1 and tree.cut == True:                                    tree.tree_stump.shake(duration=0.5, magnitude=0.5, speed=.05, direction=(0.6,0.2))                                    tree.tree_crown.shake(duration=0.5, magnitude=1.5, speed=.05, direction=(0.6, 0.2))                                    tree.health -= 1                        lock_swing_axe = True                        player.player_stats['energy'] -= 2                        player.player_stats['hunger'] -= 1                        player.player_stats['thirst'] -= 1                        invoke(enable_swing_axe, delay = 1)            # ----------------------------------------------------------------------------------------------------------    if player.state == 'inmenu':        if key == 'escape':            menu.back()    # ------------------------------------------------    if player.state == 'ingame' or paused == True:        if player.alive == True:            if key == 'escape':                if lock_pausemenu == False:                    if pmenu_open == False:                        if player.shop_open == False:                            if player.pause_menu_state == None: # Ha a pause_menübe nem nyomott meg semmi másik menüt.                                pause_menu.show_menu()                                pmenu_open = True                                paused = True                                pause_menu.anim_clock(gametime_mins, gametime_hrs) # synching clock                                if player.inventory_open == True:                                    inventory.hide_inventory()                                if weapon_wheel_open == True:                                    hud_weaponwheel.hide_weaponwheel()                                    weapon_wheel_open = False                                player.inventory_open = False                                hud.hide_money_text()                            if player.pause_menu_state == 'story':                                menu.hide_story_menu()                                player.pause_menu_state = None                        else: # ha nyitva van a shop - zárja be TODO                            hud.hide_money_text()                            hud.show_hud()                            inventory.hide_inventory()                            hud.hide_shop()                            player.shop_open = False                            if player.raid_attack == True:                                hud.show_attack_hud()                            if player.right_hand == 'colt': # ha a kezében van colt akkor miután bezárta a shopot nyissa meg újra.                                hud.show_ammo_text(revolver_ammo, full_ammo)                    elif pmenu_open == True:                        pause_menu.close_menu(player.state)                        pmenu_open = False                        paused = False                        if player.raid_attack == True:                            hud.show_attack_hud()                    lock_pausemenu = True                    invoke(enable_pausemenu, delay = 0.6)    if player.state == 'ingame' and paused == False:        if player.alive == True:            if player.builder_mode == False and player.shop_open == False and player.inventory_open == False:                if key == 'tab': # weapon wheelt kinyitja                    hud_weaponwheel.show_weaponwheel()                    weapon_wheel_open = True                if key == 'tab up': # weapon wheelt bezárja                    hud_weaponwheel.hide_weaponwheel()                    hud_weaponwheel.wheelbar_selector.fade_in(value=0, duration=0.15, delay = 0)                    weapon_wheel_open = False                    # WEAPON WHEEL TILES                    if hud_weaponwheel.get_back_selected_wheeltile() == 'right': # Ha a weapon wheel 'right' mezője aktív                        player.right_hand = 'hand'                        hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                        hud_weaponwheel.tile_selected.scale = (-0.25, -0.3, 0)                        hud_weaponwheel.tile_selected.position = (0.202, -0.021, -0.1)                        hud.hide_ammo_text()                    # //////////////////////////////////////////////////////////////////////////////////////////////////////                    if hud_weaponwheel.get_back_selected_wheeltile() == 'upper_left': # Ha a weapon wheel 'upper_left' mezője aktív                        player.right_hand = 'colt'                        hud_weaponwheel.tile_selected.rotation = (0, 0, 53)                        hud_weaponwheel.tile_selected.scale = (0.26, 0.31, 0)                        hud_weaponwheel.tile_selected.position = (-0.125, 0.125, -0.1)                        hud.show_ammo_text(revolver_ammo, full_ammo)                    # //////////////////////////////////////////////////////////////////////////////////////////////////////                    if hud_weaponwheel.get_back_selected_wheeltile() == 'left': # Ha a weapon wheel 'left' mezője aktív                        player.right_hand = 'axe' # vagy majd a lámpás                        hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                        hud_weaponwheel.tile_selected.scale = (0.25, 0.3, 0)                        hud_weaponwheel.tile_selected.position = (-0.195, -0.033, -0.1)                        hud.hide_ammo_text()            # //////////////////////////////////////////////////////////////////////////////////////////////////////            # BUILDER MODE            if key == 'c':                if player.builder_mode == True:                    builder_mode.close_builder_mode()                    hud.show_hud()                    follow_script = camera.add_script(SmoothFollow(target=player, offset=[0, 1, -80], speed=4))                    player.builder_mode = False                elif player.builder_mode == False:                    builder_mode.open_builder_mode()                    hud.hide_hud()                    camera.scripts.remove(follow_script)                    player.builder_mode = True            if player.builder_mode == True:                if key == 'left mouse down':                    if mouse.world_point:                        print(floor(mouse.world_point.x), floor(mouse.world_point.y))            # ----------------------------------------------------------------------------------------------------------            # INVENTORY            if key == 'b' and player.builder_mode == False and player.shop_open == False:                if player.inventory_open: # CLOSE INVENTORY                    inventory.hide_inventory()                    player.inventory_open = False                    hud.hide_money_text()                    if player.right_hand == 'colt':                        hud.show_ammo_text(revolver_ammo, full_ammo)                elif not player.inventory_open: # OPEN INVENTORY                    inventory.show_inventory(x = -0.24, mode = 'basic')                    player.inventory_open = True                    hud.hide_ammo_text()                    hud.show_money_text(player.player_stats['bank_balance'],player.player_stats['wallet_balance'])######################################################################################################################### CORE ACTIONS #-------------------------------------------------------------------------------------------------------#hunger_core_action_enabled = Truethirst_core_action_enabled = Trueenergy_core_action_enabled = Truehealth_core_action_enabled = Truedef player_energy_core_action(energy, status):    global energy_core_action_enabled    if player.player_stats['energy'] > 0 and player.player_stats['energy'] <= 100:        player.player_stats['energy'] += energy    if status == 'reduce':        if player.player_stats['energy'] <= 0:            if player.player_stats['energy_core'] > 1:                player.player_stats['energy_core'] -= 1    energy_core_action_enabled = True# ____________________________________________def player_health_core_action(hp, status):    global health_core_action_enabled    if status == 'reduce':        if player.player_stats['health'] > 0:            player.player_stats['health'] -= hp        if player.player_stats['health'] <= 0:            if player.player_stats['health_core'] > 0:                player.player_stats['health_core'] -= 10    if status == 'increase': # növeli az életerőt        if elapsed_time_player_got_shot >= 5:            if player.player_stats['thirst_core'] >= 15 and player.player_stats['hunger_core'] >= 25:                if player.player_stats['health_core'] > 35 and player.player_stats['health_core'] < 100:                    player.player_stats['health'] += hp        health_core_action_enabled = True# ____________________________________________def player_thirst_core_action():    global thirst_core_action_enabled    if player.player_stats['thirst'] > 0:        player.player_stats['thirst'] -= randint(0,2)    if player.player_stats['thirst'] == 0:        if player.player_stats['thirst_core'] > 0:            player.player_stats['thirst_core'] -= randint(0, 2)    if player.player_stats['thirst_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    thirst_core_action_enabled = True# ____________________________________________def player_hunger_core_action():    global hunger_core_action_enabled    if player.player_stats['hunger'] > 0:        player.player_stats['hunger'] -= randint(0,2)    if player.player_stats['hunger'] == 0:        if player.player_stats['hunger_core'] > 0:            player.player_stats['hunger_core'] -= randint(0, 2)    if player.player_stats['hunger_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    hunger_core_action_enabled = True#########################################################################################################################----------------------------------------------------------------------------------------------------------------------#time_globaled = 0last_gametime = 0gametime_all = 0 # 'ingame' töltött játékidőgametime_hrs = 6 # meghatározza a kezdeti időt órákban.gametime_mins = 0 # meghatározza a kezdeti időt percekben.elapsed_time_player_got_shot = 0anim_test = Truedef doit():    global anim_test    anim_test = Truedef hide_tree_crown(tree):    destroy(tree.tree_crown, delay = 3)    tree.tree_crown.shake(duration=0.5, magnitude=1, speed=.05, direction=(1, 0.5))    tree.tree_crown.fade_in(value=0, duration=1.5, delay=1.5)def update():    global shoot, paused, movespeed, time_globaled, last_gametime, gametime_hrs, gametime_mins, gametime_all, anim_test    global thirst_core_action_enabled, health_core_action_enabled, hunger_core_action_enabled, energy_core_action_enabled    global elapsed_time_player_got_shot    player.state = get_status() # get value from menu    if player.state == 'ingame' and paused == False and player.builder_mode == False:        # --------------------------------------------------------------------        # RAID / ATTACK        player.enemy_alive = 0        for enemy in player.enemies:            if enemy.alive == True:                player.enemy_alive += 1        # --------------------------------------------------------------------        fény1.new_position(x = player.x, y = player.y) #TODO        # CORE SAFETY        cores_list = [['health','health_core'],['thirst','thirst_core'],['power','power_core'],['hunger','hunger_core'],['energy','energy_core']]        for core in cores_list:            if player.player_stats[core[0]] < 0:                player.player_stats[core[0]] = 0            if player.player_stats[core[0]] > 100:                player.player_stats[core[0]] = 100            if player.player_stats[core[1]] < 0:                player.player_stats[core[1]] = 0            if player.player_stats[core[1]] > 50:                player.player_stats[core[1]] = 50        # [ PLAYER DEAD ] ----------------------------------------------------------------------------------------------        # HA A JÁTÉKOS MEGHAL        if player.player_stats['health_core'] <= 0 and player.alive == True:            player.alive = False            attack.defeat()            hud.show_death_screen()            print('dead')        if hud.dead_screen_status == 'respawned': # respawned / none            player.alive = True            hud.dead_screen_status = 'none'            player.player_stats['health_core'] = 25            player.player_stats['health'] = 25            player.player_stats['energy'] = 25            player.player_stats['energy_core'] = 25            player.player_stats['hunger'] = 25            player.player_stats['hunger_core'] = 12            player.player_stats['thirst'] = 35            player.player_stats['thirst_core'] = 12            player.player_stats['power'] = 0            player.player_stats['power_core'] = 0        # [ INGAME TIME ] ----------------------------------------------------------------------------------------------------------[]        # THEORY        # Minden egyes valós másodperc a játékban egy percnek felel meg        # Ennek tudatában egy játékbeli nap 24 valós percből áll.        # A játékos 6-kor kel, és legkésőbb hajnali 2-re ágyba kell bújnia. Így a játékidő egy játékbeli napra legfeljebb 20 percet jelent.        time_globaled += time.dt        elapsed_time_player_got_shot += time.dt        if time_globaled - last_gametime > 1:  # 1 másodpercenként tickel            last_gametime = time_globaled            gametime_all += 1            if gametime_hrs != 2:                gametime_mins += 1                if gametime_mins % 60 == 0:                    gametime_hrs += 1                    gametime_mins = 0                if gametime_hrs % 24 == 0:                    gametime_hrs = 0                #print(f'{gametime_hrs}:{gametime_mins}') TODO                env_light.time_set(gametime_mins + (gametime_hrs * 60))                attack.attack_management(gametime_mins + (gametime_hrs * 60))                if player.raid_attack == True and player.shop_open == False:                    hud.update_attack_hud(player.enemy_alive, player.existing_enemy, player.wave_amount, player.current_wave)                    if player.enemy_alive == 0 and player.wave_amount != player.current_wave:                        attack.start_next_wave()                    if player.enemy_alive == 0 and player.wave_amount == player.current_wave:                        attack.victory()            if hunger_core_action_enabled == True:                invoke(player_hunger_core_action, delay = (randint(40,100) / 10))                hunger_core_action_enabled = False            if thirst_core_action_enabled == True:                invoke(player_thirst_core_action, delay = (randint(40,100) / 10))                thirst_core_action_enabled = False            if health_core_action_enabled == True:                invoke(player_health_core_action, 1, 'increase', delay = 1)                health_core_action_enabled = False            if energy_core_action_enabled == True:                invoke(player_energy_core_action, randint(1, 2), 'increase', delay=(randint(10, 40) / 10))                energy_core_action_enabled = False        # [] ----------------------------------------------------------------------------------------------------------[]        # A játék információt küld a HUD-nak a játékos statisztikáiról.        # player.player_stats['health'] = 123        hud.anim_cores(player.player_stats)        '''if anim_test == True:            player.player_stats['health_core'] -= 1            player.player_stats['health'] -= 1            player.player_stats['energy_core'] -= 1            player.player_stats['energy'] -= 1            player.player_stats['power_core'] -= 1            player.player_stats['power'] -= 1            player.player_stats['hunger_core'] -= 1            player.player_stats['hunger'] -= 1            player.player_stats['thirst_core'] -= 1            player.player_stats['thirst'] -= 1            hud.anim_cores(player.player_stats)            anim_test = False            invoke(doit, delay = 0.02)'''        # [] ----------------------------------------------------------------------------------------------------------[]        # Célzás közben a játékos legyen lassabb.        if held_keys['right mouse']:            shoot = True            movespeed = 1        else:            shoot = False        # ------------------------------------        for shot_bullet in player.shot_bullet_list:            shot_bullet.world_position += shot_bullet.up * 85 * time.dt            for enemy in player.enemies:                if enemy.alive == True:                    if distance(enemy.world_position, shot_bullet.world_position) <= 1:                        enemy.alive = False                        enemy.color = color.black                        enemy.collider = None                        shot_bullet.disable()            bullet_det = shot_bullet.intersects(debug = True, ignore = (shot_bullet))            if bullet_det.hit == True:                print('eltaláltam valamit')        ################################################################################################################################        # TREE HANDLING        for tree in player.trees_list:            if distance(tree.pos, player.position) <= 12:                if player.position.y >= tree.pos[1]:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.front_layer + 0.02)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.front_layer)                else:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.back_layer + 0.02)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.back_layer)                    # //////////////////////////////////////////////////////////////////////////////////////////////////                if tree.alive:                    if player.position.y >= tree.pos[1] + 1 and player.position.y <= tree.pos[1] + 10:                        if player.position.x >= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 0.8                            tree.tree_crown.alpha = 0.8                        if player.position.x >= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                        if player.position.x <= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 0.8                            tree.tree_crown.alpha = 0.8                        if player.position.x <= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                    else:                        tree.tree_stump.alpha = 1                        tree.tree_crown.alpha = 1                ########################################################################################################                # CUT THE TREES                if tree.alive == True and tree.health == 0:                    tree.alive = False                    if player.x >= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,-90), duration = 2.2, curve = curve.in_quart)                    if player.x <= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,90), duration = 2.2, curve = curve.in_quart)                    invoke(hide_tree_crown, tree,  delay = 2)    ################################################################################################################################    # BUILDER MODE    if player.state == 'ingame' and player.builder_mode == True:        if held_keys['left mouse']:            camera.x -= mouse.velocity[0] * 30            camera.y -= mouse.velocity[1] * 30        camera.x -= held_keys['a'] * time.dt * 25        camera.x += held_keys['d'] * time.dt * 25        camera.y -= held_keys['s'] * time.dt * 25        camera.y += held_keys['w'] * time.dt * 25        if mouse.world_point:            builder_mode.update_grid(floor(mouse.world_point.x), floor(mouse.world_point.y))########################################################################################################################## [ DEFAULT OBJECTS ][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]from interactions import *def place_default_objects():    global fény1    # INTERIORS -    tent_interior1 = Interior(position = [30,125], destination = [40,125], id = 'tent', player = player)    tent_interior2 = Interior(position = [40,130], destination = [30,130], id = 'tent2', player = player)    #Markers    shop1 = Shop(x = 73.1, y = 137.9, player = player)    #LIGHT SOURCES -    fény1 = LightSource(host = player, position = [25, 125], type = 'street_lamp', color = color.yellow)    #fény1.new_position(x = 40, y = 120)    #ENVIRONMENT    tree1 = Trees(type='oak', stage=4, position=[5, 2, -0.05], cut=True, matrix=matrix, player=player)    tree2 = Trees(type='oak', stage=4, position=[8, 5, -0.05], cut=True, matrix=matrix, player=player)    tree3 = Trees(type='oak', stage=4, position=[11, 2, -0.05], cut=True, matrix=matrix, player=player)    tree4 = Trees(type='oak', stage=4, position=[18, 8, -0.05], cut=True, matrix=matrix, player=player)    #INTERACTIVE OBJECTS    # 'lamp_post' -> Lámpa oszlop    #CreatingLamps    lamp_list = [[92.3,113.8], [112.7,117.0], [119.1,135.8], [109.4,96.8], [131.2,100.8], [134.8,100.8], [85.5,106.5], [89.6,96.8]]    for loc in lamp_list:        lamp_posts = InteractiveObject(x = loc[0], y = loc[1], tag = 'lamp_post', lit = True, player = player)######################################################################################################################### [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]# CLASS-ok meghívása# a Z tengely alapból -0.15player = Player(x = 73, y = 130, invincibility = False)camera.position = (73,130)# -----------------------------------------------------------*hud = HUD(language_pack, player)menu = Menu(language_pack, hud, matrix, player)pause_menu = PauseMenu(language_pack, menu, hud, player)hud_weaponwheel = WeaponWheel(language_pack, pause_menu)env_light = LightSystem()inventory = Inventory(pause_menu, player, hud)inventory.add_item(_item_ = 'gem', category = 'food', tradeable = False, item_amount = 4)inventory.add_item(_item_ = 'bag', category = 'food', tradeable = True, item_amount = 26)#inventory.add_item(_item_ = 'gem', category = 'treasure', item_amount = 8)#inventory.add_item(_item_ = 'bag', category = 'treasure', item_amount = 2)builder_mode = BuilderModeHud()# -----------------------------------------------------------*attack = Attack()menu.show_menu()#EditorCamera()world_canvas = Entity(texture = map, origin = (-0.5, -0.5, 0), model = 'quad', collider = 'box', scale = (200,200,0), position = (0,0,.1), tag = 'canvas')follow_script = camera.add_script(SmoothFollow(target = player, offset=[0, 1, -80], speed = 4))object1 = Entity(model='cube', collider='mesh', scale=(3,5,0), color = color.green, position = (-7,2,-0.1), tag = 'building')# ----------------------------------------------------------------------------------------------------------------------*'''Cursor(texture = 'textures\misc\cursor\cursor.png', scale=.05)mouse.visible = False'''# OBJEKTUMOK INICIALIZÁLÁSAtownlevel_collision()# Mátrixból tölti be az adatokatplace_objects_from_matrix(matrix)place_default_objects() # A full alap dolgokat tölti beplace_buildings(player)base.run()