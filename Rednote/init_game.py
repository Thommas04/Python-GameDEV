# REDNOTE PROJECT 2022 - KOP / SK# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #from ursina import *from ursina.raycaster import raycastfrom os import *from random import *#from PIL import *from threading import *from pandas import DataFrame, read_excelfrom numpy import arcsinfrom math import degreesfrom pathfinding.core.diagonal_movement import DiagonalMovementfrom pathfinding.core.grid import Gridfrom pathfinding.finder.a_star import AStarFinderfrom daylight_cycle import *from collisions import *from pause_menu import *from functions import *from objects import *from menu import Menufrom menu import *from hud import *from environment import *#from my_shaders import *from ursina.shaders.screenspace_shaders.fxaa import *map = 'textures/seasons/map/'tower_graphics = 'textures/towers/tower1.png'# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #settings_file = fileread('settings/settings.rsp') # Megnyitni a settings fájlt.language = settings_file[0].split(':')[1] # kiolvasni a settings fájlból a beállított nyelvet.for file in os.listdir('./languages'):    exec('from languages.' + language + ' import *')    if file.endswith('.py'):        language_file = file.split('.')[0]        if language_file == language:            language_pack = set_language()# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #app = Ursina()window.color = rgb(16.065,32.895,28.05)window.vsync = Trueprint('vsync:',window.vsync)window.exit_button.enabled = Falseif settings_file[3].split(':')[1] == "True":    window.fps_counter.x = -0.78    window.fps_counter.font = 'fonts/pricedown.otf'    window.fps_counter.color = rgb(255, 163, 57)    window.fps_counter.alpha = 0.5else:    window.fps_counter.disable()camera.color = color.red#create_net()#background = Entity(model = 'cube', collider = 'box', scale = (1000,1000,0), color = color.dark_gray, position = (0,0,0.1))# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #class Matrix:    def __init__(self, size_x, size_y):        self.size_x = size_x        self.size_y = size_y        self.updated_tiles = [] # Ide kerülnek azok a koordináták, melyek legutóbb frissítve lettek.        self.matrix = [[{'reserved' : False,                         'type' : 'type:grass;tower:yes;plants:yes;fishing:no'                         } for x in range(size_x)] for y in range(size_y)]        self.info_dict = {}    def get_value(self, x, y, key_word): # visszaadja az adott terület értékét        try:            return self.matrix[self.size_y - y][x][key_word]        except:            print('MATRIX GET_VALUE ERROR : NEGATIVE')    def set_value(self, x, y, key_word, value): # adott területre értéket állít        self.matrix[self.size_y - y][x][key_word] = value    def print_matrix(self): # printeli a mátrixot        for x in self.matrix:            print(f'{x}')# ----------------------------------------------------------------------------------------------------------------------matrix = Matrix(size_x = 200, size_y = 200)for i in send_matrix_coords()[0]: # PATH COORDS    matrix.set_value(i[0], i[1], 'type', 'type:path;tower:no;plants:yes;fishing:no')for i in send_matrix_coords()[1]: # Collider COORDS    matrix.set_value(i[0], i[1], 'reserved', True)    matrix.set_value(i[0], i[1], 'type', 'type:collider;tower:no;plants:no;fishing:no')for i in send_matrix_coords()[2]: # Water Surface    matrix.set_value(i[0], i[1], 'reserved', True)    matrix.set_value(i[0], i[1], 'type', 'type:water;tower:no;plants:no;fishing:yes')for i in send_matrix_coords()[3]: # Stone tile COORDS    matrix.set_value(i[0], i[1], 'reserved', True)    matrix.set_value(i[0], i[1], 'type', 'type:stone;tower:no;plants:no;fishing:no')    #text = Text(text='asd', origin=(-0.5, 0), position=[i[0], i[1], -0.12], color=rgb(255,0,0), parent=scene, font='fonts/CHINESER.TTF', scale=10)# ----------------------------------------------------------------------------------------------------------------------#####alma = 'kocogtee'#####matrix_data_frame = new_tile_excel(matrix.size_x, matrix.size_y)#matrix_info_frame = new_info_excel()#rawsave_excel(matrix_info_frame,"saves/kiskocog/info_data.xlsx" , 'infoset')#####rawsave_excel(matrix_data_frame,f"saves/{alma}/tile_data.xlsx" , 'tileset')# Csak akkor tudok read_excelt használni ha már létezik a fájl#matrix_data_frame = read_excel(f"saves/{alma}/tile_data.xlsx", sheet_name = 'tileset') # beolvas#matrix_info_frame = read_excel("saves/kiskocog/info_data.xlsx", sheet_name = 'infoset') # beolvas#load_info_from_excel(matrix = matrix, data_frame = matrix_info_frame)#load_from_excel(data_frame = matrix_data_frame, matrix = matrix, excel_path ="saves/matrix.xlsx")#############################################################################################################################load_to_excel(data_frame = matrix_data_frame, matrix = matrix, excel_path = f"saves/{alma}/tile_data.xlsx", sheet = 'tileset')##matrix.set_value(2, 9, 'type', 'kekcske')##matrix.set_value(2, 10, 'type', 'béka')##matrix.set_value(2, 11, 'type', 'elment')##matrix.set_value(2, 12, 'type', 'nyaralni')##matrix.updated_tiles = [[2,9],[2,10],[2,11],[2,12]]##fast_load_to_excel(matrix_data_frame, matrix, "saves/kiskocog/tile_data.xlsx", 'tileset')##matrix.print_matrix()##print('faszomat: ',matrix.get_value(2, 11, 'type'))# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #def collison_hit():    passec = 1 # korrekciós célokraclass Player(Entity):    def reset_time(self):        self.gametime_mins = 0        self.gametime_hrs = 6        self.days += 1    def shop_get_item(self, title):        if title == 'Torony':            inventory.add_item(_item_='textures/misc/items/tower.png', category='builds', sec_type='tower', tradeable=True, placeable=True, item_amount=1)            self.amount_of_tower += 1        if title == 'Juhar mag':            inventory.add_item(_item_='textures/misc/items/maple_seed.png', category='crafts', sec_type='seeds', tradeable=True, placeable=True, item_amount=1)        if title == 'Tölgy mag':            inventory.add_item(_item_='textures/misc/items/oak_seed.png', category='crafts', sec_type='seeds', tradeable=True, placeable=True, item_amount=1)        if title == 'Mahagoni mag':            inventory.add_item(_item_='textures/misc/items/mahagoni_seed.png', category='crafts', sec_type='seeds', tradeable=True, placeable=True, item_amount=1)        if title == 'Fenyö mag':            inventory.add_item(_item_='textures/misc/items/pine_seed.png', category='crafts', sec_type='seeds', tradeable=True, placeable=True, item_amount=1)        if title == 'Kenyér':            inventory.add_item(_item_='textures/misc/items/bread.png', category='food', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)        if title == 'Kolbász':            inventory.add_item(_item_='textures/misc/items/sausage.png', category='food', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)        if title == 'Csodabogár Elixír':            inventory.add_item(_item_='textures/misc/items/charger_potion.png', category='tonic', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)        if title == 'Életerö bájital':            inventory.add_item(_item_='textures/misc/items/health_potion.png', category='tonic', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)        if title == 'Energia bájital':            inventory.add_item(_item_='textures/misc/items/energy_potion.png', category='tonic', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)        if title == 'Whisky':            inventory.add_item(_item_='textures/misc/it.png', category='food', sec_type='seeds', tradeable=True, placeable=False, item_amount=1)    def __init__(self, x, y, matrix, invincibility = False,  **kwargs):        super().__init__(self, **kwargs)        self.model = 'quad'        self.scale = (1, 1, -1)        self.rotation = (90, 0, 0)        self.position = [x, y - ec, -0.1]        self.tag = 'player'        self.alpha = 0        self.invincibility = invincibility        self.matrix = matrix        self.amount_of_tower = 2        # -=============================================================================================================        self.pause_menu_state = None        self.state = 'inmenu'  # ingame / inmenu        self.tutorial_needed = False        self.current_active_marker = None # tartalmazza, hogy milyen típusú markerban van benne.        # LOAD WORLD SETTINGS        self.selected_load_path = ''        self.matrix_dataframe = None        self.info_dataframe = None        self.cheats = False        self.fly = False        self.alive = True        self.right_hand = 'hand' # Tartalmazza, hogy mi van a játékos jobb kezében.        self.inventory_open = False        self.shop_open = False        self.builder_mode = False        self.towers_list = []        self.season = 'winter' # spring ; summer ; fall ; winer        self.rain = False        self.has_item_under_cursor = False        self.has_indicator_under_cursor = False        #SHOOTING SYSTEM        self.reloading = False        self.full_ammo = 500  # bullet        self.revolver_ammo = 6  # bullet        self.revolver_shoot_speed = 0.2  # sec        self.pull_up = True        self.aim = False        self.reload_enable = True        # TIME SYSTEM        self.time_globaled = 0        self.last_gametime = 0        self.gametime_all = 0  # 'ingame' töltött játékidő        self.gametime_hrs = 6  # meghatározza a kezdeti időt órákban.        self.gametime_mins = 0  # meghatározza a kezdeti időt percekben.        self.elapsed_time_player_got_shot = 0        # INTERIOR        self.markers_list = []        self.interior_exit_enable_byte = True        #LIGHTS        self.lights_list = []        #TREES        self.trees_list = []        self.new_trees_list = []        #BUILDINGS - INTERACTIVE LAYERS        self.building_layers_list = []        # ENEMY & RAIDS        self.raid_attack = False        self.enemies = []        self.existing_enemy = 0        self.enemy_alive = 0        self.wave_amount = 0        self.current_wave = 1        self.days = 1        self.on_horse = False        #INTERACTIVE OBJECTS        self.interactive_object_list = []        # -=============================================================================================================        self.player_stats = {'health': 100,                             'energy': 100,                             'hunger': 100,                             'thirst': 100,                             'power' : 100,                             'health_core' : 50,                             'energy_core': 50,                             'hunger_core': 50,                             'thirst_core': 50,                             'power_core': 50,                             'wallet_balance' : 52,                             'bank_balance': 565,                            }        self.cursor_item_texture = Entity(alpha = 0, texture ='hud/inventory/widgets/inventory_hover.png', scale=(0.075, 0.075, 0), position=[0, 0, 0], model='quad', parent=camera.ui, origin = (-.7, .7))        self.cursor_selected_tile = Entity(alpha = 0, texture = 'textures/misc/loose_sprites/selected_tile.png', scale=(1, 1, 0), position=[0, 0, 0], model='quad', origin = (-.5, -.5))        self.directions = ['no_up','no_left','no_down','no_right']        self.right_det = Entity(model='plane', scale=(0.2, 0.5, -0.5), position=(self.position.x + 0.6, self.position.y - 1.25 + ec, -0.1), color=color.red, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=False)        self.left_det = Entity(model='plane', scale=(0.2, 0.5, -0.5), position=(self.position.x - 0.6, self.position.y - 1.25 + ec, -0.1), color=color.brown, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=False)        self.up_det = Entity(model='plane', scale=(1, 1, -0.2), position=(self.position.x, self.position.y - 0.9 + ec, -0.1), color=color.azure, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=False)        self.down_det = Entity(model='plane', scale=(1, 1, -0.2), position=(self.position.x, self.position.y - 1.6 + ec, -0.1), color=color.pink, rotation=(90, 0, 0), tag = 'player_collision', collider='box', visible=False)        self.shot_bullet_list = []        self.player_graphics = SpriteSheetAnimation('textures/main_character/main_character_spritesheet.png', position=[x, y, -0.65], alpha = 1, tileset_size=(30, 4), scale = (1.75,2.82) ,fps=30, animations={            'idle_up': ((0, 1), (0, 1)),            'idle_right': ((0, 2), (0, 2)),            'idle_left': ((0, 3), (0, 3)),            'idle_down': ((0, 0), (0, 0)),            'walk_up': ((0, 1), (29, 1)),            'walk_right': ((0, 2), (29, 2)),            'walk_left': ((0, 3), (29, 3)),            'walk_down': ((0, 0), (29, 0)),        })        self.shadow = SpriteSheetAnimation('textures/main_character/main_character_spritesheet.png', color = color.black, origin = (0,-0.5), position=[x, y - 0.75, -0.1], rotation = [0,0,10], double_sided = True, alpha=0.01, tileset_size=(30, 4), scale=(1.75,2.82), fps=30, animations={                'idle_up': ((0, 1), (0, 1)),                'idle_right': ((0, 2), (0, 2)),                'idle_left': ((0, 3), (0, 3)),                'idle_down': ((0, 0), (0, 0)),                'walk_up': ((0, 1), (29, 1)),                'walk_right': ((0, 2), (29, 2)),                'walk_left': ((0, 3), (29, 3)),                'walk_down': ((0, 0), (29, 0)),            })        self.player_parts = [self,self.right_det, self.left_det, self.up_det, self.down_det, self.player_graphics, self.shadow]    def sleep_player(self):        self.reset_time()        bed.blacked.fade_out(value=0, duration=1.5, delay=1.5)        bed.blacked.animate_color(color.white, duration=2)        #print(self.selected_load_path)        #print(self.selected_load_path + "/tile_data.xlsx")        fast_load_to_excel(self.matrix_dataframe, matrix, self.selected_load_path + "/tile_data.xlsx", 'tileset')        rawsave_excel(self.info_dataframe, self.selected_load_path + "/info_data.xlsx", 'infoset')        env_light.light_animation = env_light.ambient_light.animate_color(rgb(179, 207, 226), duration=20)  # Nappali fény        for tree in self.new_trees_list:            if tree.stage < 5:                tree.upgrade_tree(tree.stage + 1)                tree.stage += 1    def update(self):        global movespeed, energy_core_action_enabled        #print(matrix.get_value(floor(player.position.x), floor(player.position.y + 1), 'type'))        if self.has_item_under_cursor == True:            self.cursor_item_texture.position = (mouse.position.x, mouse.position.y, -1)            self.cursor_selected_tile.position = (floor(mouse.world_point.x), floor(mouse.world_point.y), -1)            if distance(player.position,(floor(mouse.world_point.x), floor(mouse.world_point.y), -1)) <= 2:                if self.matrix.get_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'reserved') == False:                    self.cursor_selected_tile.color = color.green                    self.cursor_item_texture.color = color.white                    self.cursor_item_texture.alpha = 0.8                else:                    self.cursor_selected_tile.color = color.red                    self.cursor_item_texture.color = color.light_gray                    self.cursor_item_texture.alpha = 0.4            else:                self.cursor_selected_tile.color = color.red                self.cursor_item_texture.color = color.light_gray                self.cursor_item_texture.alpha = 0.4        if self.state == 'ingame' and paused == False and player.builder_mode == False and self.shop_open == False and cheatmenu.open == False:            right_hit = self.right_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            left_hit = self.left_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            up_hit = self.up_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            down_hit = self.down_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            # ----------------------------------------------------------------------------------------------------------            # PLAYER AND OBJECT MANAGEMENT            if train.position.y >= self.player_graphics.position.y + 3.5:                train.z = -0.5            else:                train.z = -0.66            # ----------------------------------------------------------------------------------------------------------            for interactive in self.interactive_object_list: #TODO                if distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)) <= 3.5:                    if interactive.object.position.y <= self.position.y: #objektum mögött tartózkodik                        self.player_graphics.position = [self.player_graphics.position.x, self.player_graphics.y, -0.4]                    else:                        self.player_graphics.position = [ self.player_graphics.position.x, self.player_graphics.y, -0.65]                if distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)) > 3.5 and \                        distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)) < 5:                    self.player_graphics.position = [self.player_graphics.position.x, self.player_graphics.y, -0.65]                if interactive.tag == 'lamp_post':                    if distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)) <= 5:                        c = round(distance_2d((interactive.object.x, interactive.object.y), (self.x, self.y)), 2)                        a = round(interactive.object.y - self.y, 2)                        arcs = degrees(arcsin(a/c))                        self.shadow.alpha = 0.7 - (map_range(c, 0.1, 5, 0.1, 0.7))                        if self.x > interactive.object.x and self.y > interactive.object.y:                            self.shadow.rotation = [0, 0, arcs + 90]                            self.shadow.scale = (2.25, 3.625)                        elif self.x < interactive.object.x and self.y > interactive.object.y:                            self.shadow.rotation = [0, 0, -arcs - 90]                            self.shadow.scale = (2.25, 3.625)                        elif self.x < interactive.object.x and self.y < interactive.object.y:                            self.shadow.rotation = [0, 0, -arcs - 90]                            self.shadow.scale = (-2.25, 3.625)                        elif self.x > interactive.object.x and self.y < interactive.object.y:                            self.shadow.rotation = [0, 0, arcs + 90]                            self.shadow.scale = (-2.25, 3.625)            # ------------------------------------------------------------------------------------------------------------------------------            if not held_keys['right mouse']:                if not player.aim and held_keys['shift']:                    if player.player_stats['energy_core'] >= 1:                        movespeed = 4                        if energy_core_action_enabled == True:                            if held_keys['w'] or held_keys['a'] or held_keys['s'] or held_keys['d']:                                invoke(player_energy_core_action, -2, 'reduce', delay = 0.6)                                energy_core_action_enabled = False                else:                    movespeed = 2.5            # [] ---------------------------------------------------------------------------------------------------------------------------            if right_hit.hit == False:                for parts in self.player_parts:                    parts.x += held_keys['d'] * movespeed * time.dt            else: collison_hit()            if left_hit.hit == False:                for parts in self.player_parts:                    parts.x -= held_keys['a'] * movespeed * time.dt            else: collison_hit()            if up_hit.hit == False:                for parts in self.player_parts:                    parts.y += held_keys['w'] * movespeed * time.dt            else: collison_hit()            if down_hit.hit == False:                for parts in self.player_parts:                    parts.y -= held_keys['s'] * movespeed * time.dt            else: collison_hit()            # ----------------------------------------------------------------------------------------------------------            # INTERIOR HANDLING            for marker in self.markers_list:                if marker.type_ == 'interior_marker':                    if self.interior_exit_enable_byte == True:                        if distance(self.position, marker.intexit) < 1:                            Interior.load_interior(marker)                            self.interior_exit_enable_byte = False                    if distance(self.position, marker.intexit) > 1 and distance(self.position, marker.intexit) < 2 :                        self.interior_exit_enable_byte = True                if marker.type_ == 'shop_marker':                    if distance_2d((marker.shop_marker.position.x, marker.shop_marker.position.y),(self.position.x, self.position.y)) <= 4:                        hud.show_instruction_slots(marker.type_)                    else:                        hud.hide_instruction_slots()                self.current_active_marker = marker.type_    # ------------------------------------------------------------------------------------------------------------------    # A FŐ KARAKTER SÉTÁLÁSÁNAK ANIMÁLÁSA    def input(self, key):        if key == 'escape' or key == 'right mouse down':            if self.has_item_under_cursor == True:                print('kiold')                self.has_item_under_cursor = False                self.cursor_item_texture.alpha = 0                self.cursor_selected_tile.alpha = 0                if self.right_hand == 'colt' and key != 'escape':                    hud.show_ammo_text(self.revolver_ammo, self.full_ammo)        if self.state == 'ingame' and paused == False and player.builder_mode == False and self.shop_open == False and cheatmenu.open == False:            if key == 'left mouse down' and self.inventory_open == False and player.has_item_under_cursor == True: # TODO                if self.matrix.get_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'reserved') != True: # ha nincs fenntartva a pozíció                    if self.matrix.get_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'type').split(';')[2].split(':')[1] == 'yes': # ha lehet növényt lerakni                        if distance(player.position, (floor(mouse.world_point.x), floor(mouse.world_point.y), -1)) <= 2:                            tree1 = Trees(type=f'{str(self.cursor_item_texture.texture).split("_")[0]}', stage = 1 , position=[floor(mouse.world_point.x), floor(mouse.world_point.y), -2], cut=True, matrix=matrix, player=player, by_player = True)                            self.matrix.set_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'reserved', True)                            self.matrix.updated_tiles.append([floor(mouse.world_point.x), floor(mouse.world_point.y)])                            tree_pos = self.matrix.get_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'type')                            tree_type = str(self.cursor_item_texture.texture).split("_")[0]                            tree_new = give_back_tree_tile(tree_pos, 0, f'{tree_type}', 1)                            self.matrix.set_value(floor(mouse.world_point.x), floor(mouse.world_point.y), 'type', tree_new)                            tree1.upgrade_tree(stage = 1)                            tree1.stage = 1                            self.new_trees_list.append(tree1)            # -------------------------------------------------------------------------------------            if key == 'w':                self.directions[0] = 'up'                self.player_graphics.play_animation('walk_up')                self.shadow.play_animation('walk_up')            elif key == 's':                self.directions[2] = 'down'                self.player_graphics.play_animation('walk_down')                self.shadow.play_animation('walk_down')            elif key == 'a':                self.directions[1] = 'left'                self.player_graphics.play_animation('walk_left')                self.shadow.play_animation('walk_left')            elif key == 'd':                self.directions[3] = 'right'                self.player_graphics.play_animation('walk_right')                self.shadow.play_animation('walk_right')            # --------------------------------------------------------------------------------------------------------------            if key == 's up':                                                               # ha [s] felenged                self.directions[2] = 'no_down'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                    self.shadow.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                    self.shadow.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                    self.shadow.play_animation('walk_right')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_down')                    self.shadow.play_animation('idle_down')            if key == 'a up':  # ha [a] felenged                self.directions[1] = 'no_left'                if self.directions[2] == 'down' : #                                         de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                    self.shadow.play_animation('walk_down')                elif self.directions[0] == 'up' :                                           # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                    self.shadow.play_animation('walk_up')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                    self.shadow.play_animation('walk_right')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_left')                    self.shadow.play_animation('idle_left')            if key == 'd up': # ha [d] felenged                self.directions[3] = 'no_right'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                    self.shadow.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                    self.shadow.play_animation('walk_left')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                    self.shadow.play_animation('walk_down')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_right')                    self.shadow.play_animation('idle_right')            if key == 'w up': # ha [w] felenged                self.directions[0] = 'no_up'                if self.directions[1] == 'left' :                                           # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                    self.shadow.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                    self.shadow.play_animation('walk_right')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                    self.shadow.play_animation('walk_down')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_up')                    self.shadow.play_animation('idle_up')######################################################################################################################## [ Place Class ] ###################################################################################################towers = [] # tartalmazza az összes tornyotclass Tower(Entity): # torony    def __init__(self, tag, x, y, hp, let_shoot, target, unbreakable, brokable_with, **kwargs):        global towers        super().__init__(self, **kwargs)        self.global_time = 0        self.last_time = 0        self.x = x        self.y = y        self.model = 'quad'        self.alpha = 0        self.position = (self.x, self.y, -0.1)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.scale = (3, 3, 0)        self.hp = hp        self.target = target # ellenség vagy a játékos a cél        self.let_shoot = let_shoot # lőhet-e, ez tornyok esetében jelentős        self.unbreakable = unbreakable # törhetetlen-e vagy sem - True / False        self.brokable_with = brokable_with # kitörhető valamilyen tárggyal a kézben, ez egy list is lehet.        self.shoot_cooldown = True        self.tower_bullets = []  # tartalmazza a kilőtt golyókat        towers.append(self)        self.tower_gr = Entity(texture=tower_graphics, alpha=1, model='quad', origin = (0,-0.3),scale=(4.8,8.4, 0), position=[self.x, self.y, -0.13])    def update(self):        if player.state == 'ingame' and paused == False and player.builder_mode == False:            if self.let_shoot == True:                self.global_time += time.dt                if self.global_time - self.last_time > (randint(100, 150) / 100):  # random időközönként ad engedélyt                    self.last_time = self.global_time                    self.shoot_cooldown = True                for enemy in player.enemies:                    if enemy.alive:                        if distance([enemy.x, enemy.y, 0],[self.x, self.y, 0]) <= 25:                            if self.shoot_cooldown == True:                                tower_bullet = Entity(parent = scene, model = 'sphere',                                                      color = color.red, position = self.world_position, tag = 'tower_bullet',                                                      scale = (0.2, 0.2, 0.05))                                self.tower_bullets.append(tower_bullet)                                if self.target == 'enemy':                                    tower_bullet.look_at_2d(Vec3(enemy.world_position))                            self.shoot_cooldown = False                    #[] -----------------\\\///-------[]                    for bullet in self.tower_bullets:                        if enemy.alive == True:                            if distance(enemy, bullet) <= 1:                                self.tower_bullets.remove(bullet)                                destroy(bullet)                                enemy.color = color.black                                enemy.alive = False                                enemy.collider = None                                print('torony ellenségett lőtt')                        elif distance(enemy, bullet) > 20:                            destroy(bullet)                            self.tower_bullets.remove(bullet)                for bullet in self.tower_bullets:                    bullet.world_position += bullet.up * 85 * time.dt                    bullet_det = bullet.intersects(debug = False, ignore = (bullet))######################################################################################################################## [ SPAWNER Class ] ###################################################################################################raider_sheet = 'textures/enemy/raider/raider.png'class Spawner(Entity): # includes enemies ; npc-s    def __init__(self, tag, x, y, hp, list, ammo, let_shoot, let_move, invincible, **kwargs):        super().__init__(self, **kwargs)        self.global_time = 0  #        self.last_time = 0        self.global_time_reload = 0  #        self.last_time_reload = 0        self.x = x        self.y = y        self.model = 'quad'        self.scale = (0.55,0.38,0)        self.position = (self.x, self.y, -0.1)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.alpha = 0        self.speed = (randint(60, 100) / 100)        self.hover_z = (randint(121, 530) / 1000) * -1        player.enemies.append(self)        player.existing_enemy += 1        player.enemy_alive += 1        self.stay_attack_distance = randint(2200,3000) / 100        ##################################################x        self.body_texture = Entity(texture ='textures/enemy/raider/raider.png', model = 'quad', position = (self.x, self.y, -0.13), scale = (1,1,0), alpha = 1)        # A lista tartalmazza az enemy layerjeit.        self.texture_list = [self, self.body_texture]        ##################################################x        self.list = list # a lista, amiben mozoghat        self.current_move = 0 # a jelenlegi állása a listában        self.invincible = invincible        self.alive = True        self.hp = hp        self.reload_enable = False # engedély újratöltésre - True ha üres a tár.        self.reloaded = False # Újratöltés befejezve. < késleltetve >        self.shot_bullet = [] # tartalmazza a kilőtt golyókat        self.shoot_directed = False  # True, ha a golyó kapott irányt.        self.shoot_delayed = False        self.full_ammo = ammo        self.loaded_ammo = 6        self.now_you_see_me = False # True ha a játékos a látóterében van, és nem takarja semmilyen fal.        self.let_shoot = let_shoot        self.scale = (1, 1, 0)        self.let_move = let_move    # []//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]    def update(self):        if player.state == 'ingame' and paused == False and player.builder_mode == False:            self.global_time += time.dt            if self.global_time - self.last_time > (randint(100,200) / 100):  # random időközönként ad engedélyt                self.last_time = self.global_time                self.shoot_delayed = True            if self.full_ammo != 0:                if self.reload_enable == True:                    self.global_time_reload += time.dt                    self.reload_enable = False                    if self.global_time_reload - self.last_time_reload > 3:  # random időközönként ad engedélyt                        self.last_time_reload = self.global_time_reload                        self.shoot_delayed_reload = True                        self.reloaded = True            #[]//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]            if self.alive:                if self.let_move == True:                    try:                        self.look_at_2d(Vec3(self.list[self.current_move][0], self.list[self.current_move][1], self.position.z))                    except: pass                    if distance(self, player) >= self.stay_attack_distance:                        if distance(self.position,self.list[-1]) >= 0.1:                            if self.current_move != len(self.list): # amíg a current_move nem egyenlő a lista hosszával                                for part in self.texture_list: # Végigjárja a listát, ami tartalmazza az enemy layerjeit.                                    part.position += self.up * time.dt * self.speed * 4# mozgatás                                if self.current_move != len(self.list) - 1:                                    if round(self.position.x, 1) == round(float(self.list[self.current_move][0]),1): # ellenőrzi hogy elérte e a pozíciót.                                        if round(self.position.y, 1) == round(float(self.list[self.current_move][1]),1):                                            self.current_move += 1 # tovább lép a következő pontra.              #[]------------------------------------------------------------------------------------------------------------[]                # az ellenségek lövése és köztes akadályok ellenőrzése #####################################                if self.let_shoot == True: # ha az adott enemy számára a lövés engedélyezve van.                    if distance((player.x,0,0), (self.x,0,0)) <= 10 and distance((0,player.y,0), (0,self.y,0)) <= 8:  # lőtávolság                        obstacle_test = raycast(self.world_position,                                                direction = player.world_position - self.world_position,                                                distance = distance(player.world_position, self), traverse_target = scene, ignore = [self], debug = True)                        if obstacle_test.hit: # felsorolt elemeken keresztül nem lőhet rád az enemy                            if obstacle_test.entity.tag == 'enemy' or obstacle_test.entity.tag == 'building' or obstacle_test.entity.tag == 'tower' or obstacle_test.entity.tag == 'tree':                                self.now_you_see_me = False                            else:                                self.now_you_see_me = True                    else:                        self.now_you_see_me = False                    if self.now_you_see_me == True: # ha az enemy látja a játékost.                        if self.loaded_ammo != 0:                            if self.shoot_delayed == True:                                self.shoot_delayed = False                                enemy_bullet = Entity(parent=scene, model='sphere', collider='box',                                                      color=color.red, position = self.world_position, tag = 'enemy_bullet', scale = (0.2, 0.2, 0.05))                                enemy_bullet.look_at_2d(Vec3(player.world_position))                                self.shot_bullet.append(enemy_bullet)                                sound = Audio('sounds/weapons/revolver/revolver_shot1.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy = True)                                self.loaded_ammo -= 1                                #print(self.loaded_ammo)                        if self.loaded_ammo == 0:                            self.reload_enable = True # Várnia kell 3 másodpercet míg újratölt                            if self.full_ammo != 0:                                a = 6                                if self.full_ammo < 8: # ha kevesebb mint 8 tölténye maradt, akkor csak annyit tölthessen vissza.                                    a = self.full_ammo                                if self.reloaded == True:                                    for i in range(a - self.loaded_ammo):                                        if self.full_ammo > 0:                                            self.full_ammo -= 1                                            self.loaded_ammo += 1  # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                                    #print('ammo:',self.full_ammo)            #[]--------------------------------------------------------------------------------------------------------[]            for bullet in self.shot_bullet:                bullet.world_position += bullet.up * 80 * time.dt  # a hányados takarja a sebességét a golyónak                if distance(player, bullet) <= 1:                    self.shot_bullet.remove(bullet)                    player_got_shot()                    destroy(bullet)                elif distance(player, bullet) > 20:                    self.shot_bullet.remove(bullet)                    destroy(bullet)# []-----------------------------------------------------------------------------------------------------------------[]#____________________________________________________________________________________________________________________## [ CONSTANTS ] ######################################################################################################movement_dict = {    'enemy_move_0' : [[4.6,18.8,-0.1], [13.9,25.8,-0.1], [33.5,26.9,-0.1], [46.0,34.8,-0.1], [69.1,38.0,-0.1], [72.8,48.1,-0.1], [70.0,59.4,-0.1], [63.8,64.1,-0.1], [64.6,77.2,-0.1], [65.3,97.2,-0.1], [66.5,114.1,-0.1], [74.2,118.0,-0.1], [83.4,118.6,-0.1], [104.7,119.2,-0.1]],    'enemy_move_1' : [[0.2,19.7,-0.1], [18.0,28.3,-0.1], [48.5,36.8,-0.1], [61.8,39.3,-0.1], [85.6,118.1,-0.1]],    'enemy_move_2' : [[0.7,20.4,-0.1], [17.3,39.9,-0.1], [27.7,55.4,-0.1], [46.7,59.4,-0.1], [50.7,59.4,-0.1], [53.7,62.4,-0.1], [64.2,63.5,-0.1], [64.6,79.1,-0.1], [85.5,112.4,-0.1]],    'enemy_move_3' : [[2.3,12.7,-0.1], [64.1,58.7,-0.1], [68.9,137.1,-0.1], [110.3,123.6,-0.1]],}class Attack(): # hullámok TODO    def __init__(self):        global difficulty_        self.inside_enemies = []        difficulty_ = None    def attack_management(self, time):        if time == 370 and player.days >= 2:            self.start_attack(x = -10, y = -10, difficulty = 6, wave_amount = player.days, hp = 100, ammo = 100, delay = 2)    def start_attack(self, x, y, difficulty, wave_amount, hp = 50, delay = 0, ammo = 100):        global difficulty_, x_, y_, hp_, ammo_        # LEFUT MINDEN ESETBEN HA ELKEZDŐDIK EGY ROHAM        x_ = x ; y_ = y ; hp_ = hp ; ammo_ = ammo        player.raid_attack = True        player.wave_amount = wave_amount        player.current_wave = 1        hud.show_attack_hud()        difficulty_ = difficulty        for i in range(difficulty * 2):            self.create_enemies = Spawner(tag = 'enemy', x = x + (randint(-50, 50) / 10) , y = y + (randint(-50, 50) / 10), hp = hp, ammo = ammo, list = movement_dict['enemy_move_' + str(randint(0, len(movement_dict) - 1))], let_shoot = True, let_move = True, invincible = False)            self.inside_enemies.append(self.create_enemies)    # ----------------------------------------------------------------------- []    def start_next_wave(self):        global difficulty_        player.current_wave += 1        player.existing_enemy = 0        for i in range(difficulty_ * 2):            self.create_enemies = Spawner(tag='enemy', x=x_ + (randint(-50, 50) / 10), y=y_ + (randint(-50, 50) / 10), hp=hp_, ammo=ammo_, list=movement_dict['enemy_move_' + str(randint(0, len(movement_dict) - 1))], let_shoot=True, let_move=True, invincible=False)            self.inside_enemies.append(self.create_enemies)    # ----------------------------------------------------------------------- []    def victory(self):        player.existing_enemy = 0        player.enemy_alive = 0        player.wave_amount = 0        player.current_wave = 0        print("győzelem")        player.raid_attack = False        hud.hide_attack_hud()        player.player_stats['bank_balance'] += randint(100, 300)        for enemy in self.inside_enemies:            for enemy_bullet in enemy.shot_bullet:                destroy(enemy_bullet)            player.enemies.remove(enemy)            destroy(enemy.body_texture)            destroy(enemy)    # ----------------------------------------------------------------------- []    def defeat(self): # Ha a játékos meghal        player.existing_enemy = 0        player.enemy_alive = 0        player.wave_amount = 0        player.current_wave = 0        player.raid_attack = False        hud.hide_attack_hud()        for enemy in self.inside_enemies:            for enemy_bullet in enemy.shot_bullet:                destroy(enemy_bullet)            player.enemies.remove(enemy)            destroy(enemy.body_texture)            destroy(enemy)        player.player_stats['bank_balance'] -= randint(100,200)        player.player_stats['wallet_balance'] = 0#########################################################################################################################tower01 = Tower(tag = 'tower', x = 10,y = 10, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower02 = Tower(tag = 'tower', x = 5, y = 8,  hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower03 = Tower(tag = 'tower', x = 13,y = -3, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])########################################################################################################################def revolver_delayed_reload(repeat, missing_bullet):    if player.reloading == True:        if player.revolver_ammo < 6:            player.full_ammo -= 1            sound = Audio('sounds/weapons/revolver/revolver_load_ammo.wav', loop=False, autoplay=True, balance=0.5, auto_destroy=True)            player.revolver_ammo += 1    if player.inventory_open == False:        hud.show_ammo_text(player.revolver_ammo, player.full_ammo)    if repeat == missing_bullet:        player.reloading = Falsedef pull_up_delay():    if player.pull_up == False:        player.pull_up = True# [] ------------------------------------------------------------------------------------------------------------------[]def enemy_shot():    #ray.entity.disable() ---- del enemies[enemies.index(ray.entity)] #törli az adott entityt a listából    if not ray.entity.invincible:        ray.entity.alive = True        ray.entity.color = color.red# [] ------------------------------------------------------------------------------------------------------------------[]def player_got_shot(): # Meglőtték a játékost    if player.invincibility == False:        player_health_core_action(randint(1,5), 'reduce')        player.elapsed_time_player_got_shot = 0# [] ------------ []def relocate(entity, x, y): # A* movement    grid = Grid(matrix=matrix.matrix)    start = grid.node(int(entity.x), int(entity.y))    end = grid.node(x, y)    finder = AStarFinder()    path, runs = finder.find_path(start, end, grid)    list_path = []    for i in range(len(path)):        list_path.append([path[i][0], path[i][1],0])    return list_path# [] ------------------------------------------------------------------------------------------------------------------[]pmenu_open = Falseweapon_wheel_open = Falselock_pausemenu = Falselock_swing_axe = Falsedef enable_pausemenu():    global lock_pausemenu    lock_pausemenu = Falsedef enable_swing_axe():    global lock_swing_axe    lock_swing_axe = False#----------------------------------#def reload_enable_byte():    player.reload_enable = Truepaused = Falsedef input(key):    global paused, lock_pausemenu, weapon_wheel_open, lock_swing_axe, follow_script    # Commandline    if key == '*':        if cheatmenu.open == False:            cheatmenu.open_cheatmenu()        elif cheatmenu.open == True:            cheatmenu.hide_cheatmenu()    if cheatmenu.open == True and key == 'enter up':        cheatmenu.run_command()    if player.state == 'ingame' and weapon_wheel_open == False and paused == False and cheatmenu.open == False:        if player.alive == True:            if key == 'left mouse down':                if player.builder_mode == True:                    if player.amount_of_tower >= 1:                        try:                            if distance(mouse.world_point, player.player_graphics.position) <= 12:                                print('plz')                                tower = Tower(tag = 'tower', x = mouse.world_point.x, y = mouse.world_point.y, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])                                player.towers_list.append(tower)                                player.amount_of_tower -= 1                        except: pass                        #player.building_layers_list.append(tower)                give_back_clicked_pos() # szedd ki ha vége a fejlesztésnek                #pass #enemy01.list = relocate(enemy01, 5, 5)            # ----------------------------------------------------------------------------------------------------------            # INSTRUCTION BUTTONS            #print(player.current_active_marker)            if player.current_active_marker == 'shop_marker':                if key == 'q': # BUY                    if player.inventory_open == False and player.shop_open == False:                        player.shop_open = True                        hud.show_shop()                        hud.hide_hud()                        hud.hide_ammo_text()                        hud.show_money_text(player.player_stats['bank_balance'], player.player_stats['wallet_balance'])                        hud.hide_attack_hud()                if key == 'e': # SELL                    print('sell')                    if player.inventory_open == False and player.shop_open == False:                        player.shop_open = True                        inventory.show_inventory(x = -0.8, mode = 'sell')                        hud.hide_hud()                        hud.hide_ammo_text()                        hud.show_money_text(player.player_stats['bank_balance'],player.player_stats['wallet_balance'])                        hud.hide_attack_hud()            # ----------------------------------------------------------------------------------------------------------            global bullet, ray, pmenu_open            if player.right_hand == 'colt':                if key == 'left mouse down' and player.inventory_open == False and player.shop_open == False and player.has_item_under_cursor == False:                    if player.pull_up == True:                        if player.revolver_ammo > 0:                            if mouse.world_point:                                if player.aim == True: # Ha a karakter céloz, mikozbe lő                                    direction = mouse.world_point.x, mouse.world_point.y, 0                                if player.aim == False: # Ha a karakter nem céloz - eredmény hogy nagyobb a szóras                                    direction = mouse.world_point.x + (randint(-300, 300) / 100), mouse.world_point.y + (randint(-500, 500) / 100), 0                                bullet = Entity(parent = scene, model = 'sphere', color = color.black, position = player.position, tag ='projectile', scale = (0.2, 0.2, 0.2))                                bullet.look_at_2d(Vec3(direction))                                player.shot_bullet_list.append(bullet)                                player.pull_up = False                                player.reloading = False                                sound = Audio('sounds/weapons/revolver/revolver_shot1.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy = True)                                player.revolver_ammo -= 1                                invoke(pull_up_delay, delay = player.revolver_shoot_speed)                        else:                            sound = Audio(f'sounds/weapons/revolver/revolver_empty{randint(1,2)}.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)                    # -------------------------------------------------------------------------                    if player.inventory_open == False:                        hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                if player.reload_enable == True:                    player.reload_enable = False                    invoke(reload_enable_byte, delay = 0.3)                    if key == 'r' and player.reloading == False: # reload                        sound = Audio('sounds/weapons/revolver/revolver_open_cyl.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)                        if player.revolver_ammo < 6:                            player.reloading = True                            for i in range(1, 7 - player.revolver_ammo):                                if player.full_ammo > 0:                                    invoke(revolver_delayed_reload, i, 6 - player.revolver_ammo, delay = i * 0.3)                                    print(i, 6 - player.revolver_ammo)                        if player.inventory_open == False and player.shop_open == False and player.builder_mode == False:                            hud.show_ammo_text(player.revolver_ammo, player.full_ammo)            # ----------------------------------------------------------------------------------------------------------            # CUTTING THE TREES            if player.right_hand == 'axe':                if lock_swing_axe == False:                    if key == 'left mouse down':                        for tree in player.trees_list:                            #print('player',player.position, ', tree:',tree.pos)                            #print(distance(player.position, tree.pos))                            if distance(player.position, tree.pos) <= 2.3:                                if tree.mouse_on == True and tree.health >= 1 and tree.cut == True:                                    tree.tree_stump.shake(duration=0.2, magnitude=0.5, speed=.05, direction=(0.6,0.2))                                    tree.tree_crown.shake(duration=0.2, magnitude=1, speed=.05, direction=(0.6, 0.2))                                    tree.health -= 1                        lock_swing_axe = True                        player.player_stats['energy'] -= 2                        player.player_stats['hunger'] -= 1                        player.player_stats['thirst'] -= 1                        invoke(enable_swing_axe, delay = 1)            # ----------------------------------------------------------------------------------------------------------    if player.state == 'inmenu':        if key == 'escape':            menu.back()    # ------------------------------------------------    if player.state == 'ingame' or paused == True and cheatmenu.open == False:        if player.alive == True:            if key == 'escape':                if lock_pausemenu == False:                    if pmenu_open == False:                        env_light.stop_time()                        if player.shop_open == False:                            if player.pause_menu_state == None: # Ha a pause_menübe nem nyomott meg semmi másik menüt.                                pause_menu.show_menu()                                pmenu_open = True                                paused = True                                pause_menu.anim_clock(player.gametime_mins, player.gametime_hrs) # synching clock                                if player.inventory_open == True:                                    inventory.hide_inventory()                                if weapon_wheel_open == True:                                    hud_weaponwheel.hide_weaponwheel()                                    weapon_wheel_open = False                                player.inventory_open = False                                hud.hide_money_text()                            if player.pause_menu_state == 'story':                                menu.hide_story_menu()                                player.pause_menu_state = None                        else: # ha nyitva van a shop - zárja be TODO                            hud.hide_money_text()                            hud.show_hud()                            inventory.hide_inventory()                            hud.hide_shop()                            player.shop_open = False                            if player.raid_attack == True:                                hud.show_attack_hud()                            if player.right_hand == 'colt': # ha a kezében van colt akkor miután bezárta a shopot nyissa meg újra.                                hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                    elif pmenu_open == True:                        env_light.start_time()                        pause_menu.close_menu(player.state)                        pmenu_open = False                        paused = False                        if player.right_hand == 'colt':                            hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                        if player.raid_attack == True:                            hud.show_attack_hud()                    lock_pausemenu = True                    invoke(enable_pausemenu, delay = 0.6)    if player.state == 'ingame' and paused == False and cheatmenu.open == False:        if player.alive == True:            if player.builder_mode == False and player.shop_open == False and player.inventory_open == False:                if key == 'tab': # weapon wheelt kinyitja                    hud_weaponwheel.show_weaponwheel()                    weapon_wheel_open = True                    hud.hide_item_under_cursor()                if key == 'tab up': # weapon wheelt bezárja                    hud_weaponwheel.hide_weaponwheel()                    hud_weaponwheel.wheelbar_selector.fade_in(value=0, duration=0.15, delay = 0)                    weapon_wheel_open = False                    if player.right_hand == 'colt':                        sound = Audio('sounds/weapons/revolver/revolver_putback.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)                    # WEAPON WHEEL TILES                    if hud_weaponwheel.get_back_selected_wheeltile() == 'right': # Ha a weapon wheel 'right' mezője aktív                        player.right_hand = 'hand'                        hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                        hud_weaponwheel.tile_selected.scale = (-0.25, -0.3, 0)                        hud_weaponwheel.tile_selected.position = (0.202, -0.021, -0.1)                        lantern_light.turn_off()                        hud.hide_ammo_text()                    # //////////////////////////////////////////////////////////////////////////////////////////////////////                    if hud_weaponwheel.get_back_selected_wheeltile() == 'upper_left': # Ha a weapon wheel 'upper_left' mezője aktív                        sound = Audio('sounds/weapons/revolver/revolver_putout.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)                        player.right_hand = 'colt'                        hud_weaponwheel.tile_selected.rotation = (0, 0, 53)                        hud_weaponwheel.tile_selected.scale = (0.26, 0.31, 0)                        hud_weaponwheel.tile_selected.position = (-0.125, 0.125, -0.1)                        lantern_light.turn_off()                        hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                    # //////////////////////////////////////////////////////////////////////////////////////////////////////                    if hud_weaponwheel.get_back_selected_wheeltile() == 'left': # Ha a weapon wheel 'left' mezője aktív                        player.right_hand = 'axe' # vagy majd a lámpás                        hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                        hud_weaponwheel.tile_selected.scale = (0.25, 0.3, 0)                        hud_weaponwheel.tile_selected.position = (-0.195, -0.033, -0.1)                        lantern_light.turn_off()                        hud.hide_ammo_text()                    if hud_weaponwheel.get_back_selected_wheeltile() == 'lower_left': # Ha a weapon wheel 'left' mezője aktív                        player.right_hand = 'lantern' # vagy majd a lámpás                        hud_weaponwheel.tile_selected.rotation = (0, 0, -45)                        hud_weaponwheel.tile_selected.scale = (0.25, 0.3, 0)                        hud_weaponwheel.tile_selected.position = (-0.13, -0.17, -0.1)                        lantern_light.turn_on()                        hud.hide_ammo_text()            # //////////////////////////////////////////////////////////////////////////////////////////////////////            # BUILDER MODE            if key == 'c':                if player.builder_mode == True:                    builder_mode.close_builder_mode()                    hud.show_hud()                    follow_script = camera.add_script(SmoothFollow(target=player, offset=[0, 1, -54], speed=4))                    player.builder_mode = False                elif player.builder_mode == False:                    builder_mode.open_builder_mode()                    hud.hide_hud()                    camera.scripts.remove(follow_script)                    player.builder_mode = True            if player.builder_mode == True:                if key == 'left mouse down':                    if mouse.world_point:                        pass #print(floor(mouse.world_point.x), floor(mouse.world_point.y))            # ----------------------------------------------------------------------------------------------------------            # INVENTORY            if key == 'b' and player.builder_mode == False and player.shop_open == False:                if player.inventory_open: # CLOSE INVENTORY                    inventory.hide_inventory()                    player.inventory_open = False                    hud.hide_money_text()                    if player.right_hand == 'colt':                        hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                elif not player.inventory_open: # OPEN INVENTORY                    if player.has_item_under_cursor == True:                        player.has_item_under_cursor = False                        player.cursor_item_texture.alpha = 0                        player.cursor_selected_tile.alpha = 0                        if player.right_hand == 'colt' and key != 'escape':                            hud.show_ammo_text(player.revolver_ammo, player.full_ammo)                    inventory.show_inventory(x = -0.24, mode = 'basic')                    player.inventory_open = True                    hud.hide_ammo_text()                    hud.show_money_text(player.player_stats['bank_balance'],player.player_stats['wallet_balance'])######################################################################################################################### CORE ACTIONS #-------------------------------------------------------------------------------------------------------#hunger_core_action_enabled = Truethirst_core_action_enabled = Trueenergy_core_action_enabled = Truehealth_core_action_enabled = Truedef player_energy_core_action(energy, status):    global energy_core_action_enabled    if player.player_stats['energy'] > 0 and player.player_stats['energy'] <= 100:        player.player_stats['energy'] += energy    if status == 'reduce':        if player.player_stats['energy'] <= 0:            if player.player_stats['energy_core'] > 1:                player.player_stats['energy_core'] -= 1    energy_core_action_enabled = True# ____________________________________________def player_health_core_action(hp, status):    global health_core_action_enabled    if status == 'reduce':        if player.player_stats['health'] > 0:            player.player_stats['health'] -= hp        if player.player_stats['health'] <= 0:            if player.player_stats['health_core'] > 0:                player.player_stats['health_core'] -= 10    if status == 'increase': # növeli az életerőt        if player.elapsed_time_player_got_shot >= 5:            if player.player_stats['thirst_core'] >= 15 and player.player_stats['hunger_core'] >= 25:                if player.player_stats['health_core'] > 35 and player.player_stats['health_core'] < 100:                    player.player_stats['health'] += hp        health_core_action_enabled = True# ____________________________________________def player_thirst_core_action():    global thirst_core_action_enabled    if player.player_stats['thirst'] > 0:        player.player_stats['thirst'] -= randint(0,2)    if player.player_stats['thirst'] == 0:        if player.player_stats['thirst_core'] > 0:            player.player_stats['thirst_core'] -= randint(0, 2)    if player.player_stats['thirst_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    thirst_core_action_enabled = True# ____________________________________________def player_hunger_core_action():    global hunger_core_action_enabled    if player.player_stats['hunger'] > 0:        player.player_stats['hunger'] -= randint(0,2)    if player.player_stats['hunger'] == 0:        if player.player_stats['hunger_core'] > 0:            player.player_stats['hunger_core'] -= randint(0, 2)    if player.player_stats['hunger_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    hunger_core_action_enabled = True#########################################################################################################################----------------------------------------------------------------------------------------------------------------------#anim_test = Truedef doit():    global anim_test    anim_test = Truedef hide_tree_crown(tree):    destroy(tree.tree_crown, delay = 3)    tree.tree_crown.shake(duration=0.5, magnitude=1, speed=.05, direction=(1, 0.5))    tree.tree_crown.fade_in(value=0, duration=1.5, delay=1.5)def update():    global paused, movespeed, anim_test    global thirst_core_action_enabled, health_core_action_enabled, hunger_core_action_enabled, energy_core_action_enabled    player.state = get_status() # get value from menu    if player.state == 'ingame' and paused == False and player.builder_mode == False:        hud.minimap_bg.texture_offset = (((player.position.x / 2) / 100) - 0.1, ((player.position.y / 2) / 100) - 0.1)        # --------------------------------------------------------------------        # RAID / ATTACK        player.enemy_alive = 0        for enemy in player.enemies:            if enemy.alive == True:                player.enemy_alive += 1        # --------------------------------------------------------------------        lantern_light.new_position(x = player.x, y = player.y) #TODO        # CORE SAFETY        cores_list = [['health','health_core'],['thirst','thirst_core'],['power','power_core'],['hunger','hunger_core'],['energy','energy_core']]        for core in cores_list:            if player.player_stats[core[0]] < 0:                player.player_stats[core[0]] = 0            if player.player_stats[core[0]] > 100:                player.player_stats[core[0]] = 100            if player.player_stats[core[1]] < 0:                player.player_stats[core[1]] = 0            if player.player_stats[core[1]] > 50:                player.player_stats[core[1]] = 50        # [ PLAYER DEAD ] ----------------------------------------------------------------------------------------------        # HA A JÁTÉKOS MEGHAL        if player.player_stats['health_core'] <= 0 and player.alive == True:            player.alive = False            attack.defeat()            hud.show_death_screen()            print('dead')        if hud.dead_screen_status == 'respawned': # respawned / none            player.alive = True            hud.dead_screen_status = 'none'            player.player_stats['health_core'] = 25            player.player_stats['health'] = 25            player.player_stats['energy'] = 25            player.player_stats['energy_core'] = 25            player.player_stats['hunger'] = 25            player.player_stats['hunger_core'] = 12            player.player_stats['thirst'] = 35            player.player_stats['thirst_core'] = 12            player.player_stats['power'] = 0            player.player_stats['power_core'] = 0        # [ INGAME TIME ] ----------------------------------------------------------------------------------------------------------[]        # THEORY        # Minden egyes valós másodperc a játékban egy percnek felel meg        # Ennek tudatában egy játékbeli nap 24 valós percből áll.        # A játékos 6-kor kel, és legkésőbb hajnali 2-re ágyba kell bújnia. Így a játékidő egy játékbeli napra legfeljebb 20 percet jelent.        player.time_globaled += time.dt        player.elapsed_time_player_got_shot += time.dt        if player.time_globaled - player.last_gametime > 1:  # 1 másodpercenként tickel            player.last_gametime = player.time_globaled            player.gametime_all += 1            if player.gametime_hrs != 2:                player.gametime_mins += 1                if player.gametime_mins % 60 == 0:                    player.gametime_hrs += 1                    player.gametime_mins = 0                if player.gametime_hrs % 24 == 0:                    player.gametime_hrs = 0                #print(f'{player.gametime_hrs}:{player.gametime_mins}') TODO                env_light.time_set(player.gametime_mins + (player.gametime_hrs * 60))                attack.attack_management(player.gametime_mins + (player.gametime_hrs * 60))                if player.raid_attack == True and player.shop_open == False:                    hud.update_attack_hud(player.enemy_alive, player.existing_enemy, player.wave_amount, player.current_wave)                    if player.enemy_alive == 0 and player.wave_amount != player.current_wave:                        attack.start_next_wave()                    if player.enemy_alive == 0 and player.wave_amount == player.current_wave:                        attack.victory()            if hunger_core_action_enabled == True:                invoke(player_hunger_core_action, delay = (randint(40,100) / 10))                hunger_core_action_enabled = False            if thirst_core_action_enabled == True:                invoke(player_thirst_core_action, delay = (randint(40,100) / 10))                thirst_core_action_enabled = False            if health_core_action_enabled == True:                invoke(player_health_core_action, 1, 'increase', delay = 1)                health_core_action_enabled = False            if energy_core_action_enabled == True:                invoke(player_energy_core_action, randint(1, 2), 'increase', delay=(randint(10, 40) / 10))                energy_core_action_enabled = False        # [] ----------------------------------------------------------------------------------------------------------[]        # A játék információt küld a HUD-nak a játékos statisztikáiról.        # player.player_stats['health'] = 123        hud.anim_cores(player.player_stats)        '''if anim_test == True:            player.player_stats['health_core'] -= 1            player.player_stats['health'] -= 1            player.player_stats['energy_core'] -= 1            player.player_stats['energy'] -= 1            player.player_stats['power_core'] -= 1            player.player_stats['power'] -= 1            player.player_stats['hunger_core'] -= 1            player.player_stats['hunger'] -= 1            player.player_stats['thirst_core'] -= 1            player.player_stats['thirst'] -= 1            hud.anim_cores(player.player_stats)            anim_test = False            invoke(doit, delay = 0.02)'''        # [] ----------------------------------------------------------------------------------------------------------[]        # Célzás közben a játékos legyen lassabb.        if held_keys['right mouse'] and player.right_hand == 'colt':            if player.aim == False:                shot_sound = Audio('sounds/weapons/revolver/revolver_aim_on.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)            player.aim = True            movespeed = 1        else:            if player.aim == True:                shot_sound = Audio('sounds/weapons/revolver/revolver_aim_off.ogg', loop=False, autoplay=True, balance=0.5, auto_destroy=True)            player.aim = False        # ------------------------------------        for shot_bullet in player.shot_bullet_list:            shot_bullet.world_position += shot_bullet.up * 85 * time.dt            for enemy in player.enemies:                if enemy.alive == True:                    if distance(enemy.world_position, shot_bullet.world_position) <= 1:                        enemy.alive = False                        enemy.color = color.black                        enemy.collider = None                        shot_bullet.disable()            bullet_det = shot_bullet.intersects(debug = True, ignore = (shot_bullet))            if bullet_det.hit == True:                print('eltaláltam valamit')        ################################################################################################################################        # TREE HANDLING        for tree in player.trees_list:            if distance(tree.pos, player.position) <= 8:                if player.position.y >= tree.pos[1]:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.front_layer + 0.01)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.front_layer )                else:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.back_layer + 0.01)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.back_layer)                    # //////////////////////////////////////////////////////////////////////////////////////////////////                if tree.alive:                    if player.position.y >= tree.pos[1] + 1 and player.position.y <= tree.pos[1] + 10:                        if player.position.x >= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 0.9                            tree.tree_crown.alpha = 0.9                        if player.position.x >= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                        if player.position.x <= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 0.9                            tree.tree_crown.alpha = 0.9                        if player.position.x <= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                    else:                        tree.tree_stump.alpha = 1                        tree.tree_crown.alpha = 1                ########################################################################################################                # CUT THE TREES                if tree.alive == True and tree.health == 0:                    tree.alive = False                    if player.x >= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,-90), duration = 2.2, curve = curve.in_quart)                    if player.x <= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,90), duration = 2.2, curve = curve.in_quart)                    invoke(hide_tree_crown, tree,  delay = 2)                    inventory.add_item(_item_='textures/misc/items/wood.png', category='crafts', sec_type='wood',tradeable=True, placeable=False, item_amount=randint(3,8))                    inventory.add_item(_item_=f'textures/misc/items/{tree.type_}_seed.png', category='crafts', sec_type='wood',tradeable=True, placeable=True, item_amount=randint(1,2))    ################################################################################################################################    # BUILDER MODE    if player.state == 'ingame' and player.builder_mode == True:        if held_keys['left mouse']:            camera.x -= mouse.velocity[0] * 30            camera.y -= mouse.velocity[1] * 30        camera.x -= held_keys['a'] * time.dt * 25        camera.x += held_keys['d'] * time.dt * 25        camera.y -= held_keys['s'] * time.dt * 25        camera.y += held_keys['w'] * time.dt * 25        if mouse.world_point:            builder_mode.update_grid(floor(mouse.world_point.x), floor(mouse.world_point.y))########################################################################################################################## [ DEFAULT OBJECTS ][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]pine_trees_list = [[83,134],[98,125],[89,121],[21,107],[19,101],[1,88],[52,88],[24,109],[84,111],[97,152]]oak_trees_list = [[46,107],[36,111],[66,123],[83,121],[123,93],[163,86],[81,105],[166,102],[191,17]]mahagoni_trees_list = [[43,102],[54,96],[73,100],[77,90],[83,79],[80,155],[181,60],[25,112],[59,110]]maple_trees_list = [[35,76],[54,76],[76,77],[45,77],[56,80],[185,47],[197,16],[25,100],[5,97]]from interactions import *def place_default_objects():    global lantern_light    # INTERIORS -    saloon_interior = Interior(position = [129.5,118], destination = [62,232], id = 'tent', player = player, bed = bed)    #Markers    shop1 = Shop(x = 73.1, y = 137.9, player = player)    #LIGHT SOURCES -    lantern_light = LightSource(host = player, position = [25, 125], type ='street_lamp', color = color.yellow)    lantern_light.turn_off()    #fény1.new_position(x = 40, y = 120)    #ENVIRONMENT    for trees in pine_trees_list:        tree1 = Trees(type='pine', stage=5, position=[trees[0], trees[1], -0.05], cut=True, matrix=matrix, player=player)    for trees in oak_trees_list:        tree1 = Trees(type='oak', stage=5, position=[trees[0], trees[1], -0.05], cut=True, matrix=matrix, player=player)    for trees in mahagoni_trees_list:        tree1 = Trees(type='mahagoni', stage=5, position=[trees[0], trees[1], -0.05], cut=True, matrix=matrix, player=player)    for trees in maple_trees_list:        tree1 = Trees(type='maple', stage=5, position=[trees[0], trees[1], -0.05], cut=True, matrix=matrix, player=player)    #INTERACTIVE OBJECTS    # 'lamp_post' -> Lámpa oszlop    #CreatingLamps    lamp_list = [[94,112], [87,104], [91,94], [113,94], [135,98], [138,98], [116,114], [123,134]]    for loc in lamp_list:        lamp_posts = InteractiveObject(x = loc[0], y = loc[1], tag = 'lamp_post', lit = True, player = player)######################################################################################################################### [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]# CLASS-ok meghívása# a Z tengely alapból -0.15player = Player(matrix = matrix, x = 73, y = 130, invincibility = False) # 73,130 - bolt előtt // 50,250 - interiorcamera.orthographic = Truecamera.position = (73,130)camera.fov = 20# -----------------------------------------------------------*hud = HUD(language_pack, player)menu = Menu(language_pack, hud, matrix, player)menu.start_sound()pause_menu = PauseMenu(language_pack, menu, hud, player)hud_weaponwheel = WeaponWheel(language_pack, pause_menu)env_light = LightSystem(player)inventory = Inventory(pause_menu, player, hud)inventory.add_item(_item_ = 'textures/misc/items/oak_seed.png', category = 'crafts', sec_type = 'seeds', tradeable = True, placeable = True, item_amount = 8)inventory.add_item(_item_ = 'textures/misc/items/pine_seed.png', category = 'crafts', sec_type = 'seeds',tradeable = True, placeable = True, item_amount = 8)inventory.add_item(_item_ = 'textures/misc/items/mahagoni_seed.png', category = 'crafts', sec_type = 'seeds',tradeable = True, placeable = True, item_amount = 8)inventory.add_item(_item_ = 'textures/misc/items/maple_seed.png', category = 'crafts', sec_type = 'seeds',tradeable = True, placeable = True, item_amount = 8)inventory.add_item(_item_ = 'textures/misc/items/tower.png', category = 'builds', sec_type = 'tower', tradeable = True, placeable = False, item_amount = 2)inventory.add_item(_item_ = 'textures/misc/items/health_potion.png', category = 'tonic', sec_type = 'potion',tradeable = True, placeable = False, item_amount = 4)inventory.add_item(_item_ = 'textures/misc/items/charger_potion.png', category = 'tonic', sec_type = 'potion',tradeable = True, placeable = False, item_amount = 6)inventory.add_item(_item_ = 'textures/misc/items/energy_potion.png', category = 'tonic', sec_type = 'potion',tradeable = True, placeable = False, item_amount = 5)inventory.add_item(_item_ = 'textures/misc/items/dead_eye_potion.png', category = 'tonic', sec_type = 'potion',tradeable = True, placeable = False, item_amount = 2)inventory.add_item(_item_ = 'textures/misc/items/gem.png', category = 'valuables', sec_type = 'gem',tradeable = True, placeable = False, item_amount = 5)inventory.add_item(_item_ = 'textures/misc/items/orb.png', category = 'valuables', sec_type = 'gem',tradeable = True, placeable = False, item_amount = 12)inventory.add_item(_item_ = 'textures/misc/items/bag.png', category = 'card', sec_type = 'common',tradeable = True, placeable = False, item_amount = 6)inventory.add_item(_item_ = 'textures/misc/items/bow_arrow.png', category = 'card', sec_type = 'combat',tradeable = True, placeable = False, item_amount = 64)inventory.add_item(_item_ = 'textures/misc/items/sword.png', category = 'card', sec_type = 'combat',tradeable = True, placeable = False, item_amount = 1)inventory.add_item(_item_ = 'textures/misc/items/bread.png', category = 'food', sec_type = 'grains',tradeable = True, placeable = False, item_amount = 3)inventory.add_item(_item_ = 'textures/misc/items/radish.png', category = 'food', sec_type = 'vegetable',tradeable = True, placeable = False, item_amount = 6)inventory.add_item(_item_ = 'textures/misc/items/steak.png', category = 'food', sec_type = 'meat',tradeable = True, placeable = False, item_amount = 3)inventory.add_item(_item_ = 'textures/misc/items/sausage.png', category = 'food', sec_type = 'meat',tradeable = True, placeable = False, item_amount = 3)inventory.add_item(_item_ = 'textures/misc/items/whisky.png', category = 'food', sec_type = 'drink',tradeable = True, placeable = False, item_amount = 8)weather = Weather(player)builder_mode = BuilderModeHud()################################################################# -----------------------------------------------------------*attack = Attack()menu.show_menu()#EditorCamera()world_canvas = Entity(texture = map + f'rustfort_{player.season}.png', origin = (-0.5, -0.5, 30), model = 'quad', collider = 'box', scale = (200,200,0), position = (0,0,0), tag = 'canvas')follow_script = camera.add_script(SmoothFollow(target = player, offset=[0, 1, -20], speed = 4))train = Entity(texture = 'textures/misc/train.png', model = 'quad', scale = (21.15,9.225,0), position = (57,42,-0.6), tag = 'train')object1 = Entity(model='cube', collider='mesh', scale=(3,5,0), color = color.green, position = (-7,2,-0.1), tag = 'building')# ----------------------------------------------------------------------------------------------------------------------*Cursor(texture = 'textures\misc\cursor\cursor_graph.png', scale=(0.0352,0.0432), origin = (-.5, .5))mouse.visible = False# OBJEKTUMOK INICIALIZÁLÁSAtownlevel_collision()# Mátrixból tölti be az adatokatbed = Clicks(x = 34, y = 99.5, command = 'sleep', player = player)place_default_objects() # A full alap dolgokat tölti beplace_buildings(player)cheatmenu = CheatMenu(player, weather, world_canvas)camera.shader = fxaa_shaderbase.run()