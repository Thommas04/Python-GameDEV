# REDNOTE PROJECT 2022 - KOP / SK# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #from ursina import *from ursina.raycaster import raycastfrom os import *from random import *#from PIL import *from threading import *from pandas import DataFrame, read_excelfrom pathfinding.core.diagonal_movement import DiagonalMovementfrom pathfinding.core.grid import Gridfrom pathfinding.finder.a_star import AStarFinderfrom daylight_cycle import *from collisions import *from pause_menu import *from functions import *from objects import *from menu import Menufrom menu import *from hud import *from environment import *# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #settings_file = fileread('settings/settings.rsp') # Megnyitni a settings fájlt.language = settings_file[0].split(':')[1] # kiolvasni a settings fájlból a beállított nyelvet.for file in os.listdir('./languages'):    exec('from languages.' + language + ' import *')    if file.endswith('.py'):        language_file = file.split('.')[0]        if language_file == language:            language_pack = set_language()# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #app = Ursina()window.color = rgb(16.065,32.895,28.05)window.vsync = Falseprint('vsync:',window.vsync)place_all_objects()townlevel_collision()window.exit_button.enabled = Falseprint(settings_file[3].split(':')[1])if settings_file[3].split(':')[1] == "True":    window.fps_counter.x = -0.78    window.fps_counter.font = 'fonts/pricedown.otf'    window.fps_counter.color = rgb(255, 163, 57)    window.fps_counter.alpha = 0.5else:    window.fps_counter.disable()#EditorCamera()#create_net()#background = Entity(model = 'cube', collider = 'box', scale = (1000,1000,0), color = color.dark_gray, position = (0,0,0.1))# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## ingame / inmenustate = 'inmenu'# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## 2D MATRIX# minden elemének eleme egy lista, amelynek#               - 0. eleme : / szabad e az adott terület [ True / False ]#               - 1. eleme: / mi foglalja el a területet, és az adott elem pontos paraméterei.#               - 2. eleme: /class Matrix:    def __init__(self, size_x, size_y):        self.size_x = size_x        self.size_y = size_y        self.matrix = [[{'reserved' : False,                         'type' : None,                         'hp' : None,                         'arg1' : None,                         'arg2' : None                         } for x in range(size_x)] for y in range(size_y)]    def get_value(self, x, y, key_word): # visszaadja az adott terület értékét        return self.matrix[y][x][key_word]    def set_value(self, x, y, key_word, value): # adott területre értéket állít        self.matrix[y][x][key_word] = value    def g_print(self): # printeli a mátrixot        for x in self.matrix:            print(f'{x}')# ----------------------------------------------------------------------------------------------------------------------matrix = Matrix(size_x = 100, size_y = 100)matrix.set_value(3, 4, 'type', 'grass')matrix.set_value(0, 0, 'type', 'nullanulla')matrix.set_value(1, 0, 'type', 'egynul')matrix.set_value(0, 1, 'type', 'nulegy')matrix.set_value(9, 9, 'type', 'kilkil')matrix.set_value(8, 9, 'type', 'nyolckil')print(matrix.get_value(3, 4, 'type'))# ----------------------------------------------------------------------------------------------------------------------data_frame = new_excel(matrix.size_x, matrix.size_y)# Csak akkor tudok read_excelt használni ha már létezik a fájl#data_frame = read_excel("saves/matrix.xlsx", sheet_name = 'savetest') # beolvas#load_from_excel(data_frame = data_frame, matrix = matrix, excel_path = "saves/matrix.xlsx")#########################################################################################################################save_excel(data_frame = data_frame, path = "saves/matrix.xlsx", sheet = 'savetest')load_to_excel(data_frame = data_frame, matrix = matrix, excel_path = "saves/matrix.xlsx", sheet = 'savetest')# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #def collison_hit():    passclass Player(Entity):    def __init__(self, x, y, invincibility = False,  **kwargs):        super().__init__(self, **kwargs)        self.model = 'quad'        self.scale = (1, 1, -1)        self.rotation = (90, 0, 0)        self.position = [x, y, -0.1]        self.tag = 'player'        self.alpha = 0        self.invincibility = invincibility        self.alive = True        self.right_hand = 'hand' # Tartalmazza, hogy mi van a játékos jobb kezében.        self.inventory_open = False        self.builder_mode = False        self.player_stats = {'health': 100,                             'energy': 100,                             'hunger': 100,                             'thirst': 100,                             'power' : 100,                             'health_core' : 50,                             'energy_core': 50,                             'hunger_core': 50,                             'thirst_core': 50,                             'power_core': 50,                             'wallet_balance' : 454565.9,                             'bank_balance': 52,                            }        self.directions = ['no_up','no_left','no_down','no_right']        self.right_det = Entity(model='plane', scale=(0.2, 1, -1), position=(0.5, -0.7, -0.1), color=color.red, rotation=(90, 0, 0), collider='box', tag='collision', visible=False)        self.left_det = Entity(model='plane', scale=(0.2, 1, -1), position=(-0.5, -0.7, -0.1), color=color.brown, rotation=(90, 0, 0), collider='box', tag='collision', visible=False)        self.up_det = Entity(model='plane', scale=(1, 1, -0.2), position=(0, -0.2, -0.1), color=color.azure, rotation=(90, 0, 0), collider='box', tag='collision', visible=False)        self.down_det = Entity(model='plane', scale=(1, 1, -0.2), position=(0, -1.2, -0.1), color=color.pink, rotation=(90, 0, 0), collider='box', tag='collision', visible=False)        self.shot_bullet_list = []        self.player_graphics = SpriteSheetAnimation('textures/main_character/main_character_spritesheet.png', position=(x, y, -0.15), tileset_size=(30, 4), scale = (2.25,3.625) ,fps=30, animations={            'idle_up': ((0, 1), (0, 1)),            'idle_right': ((0, 2), (0, 2)),            'idle_left': ((0, 3), (0, 3)),            'idle_down': ((0, 0), (0, 0)),            'walk_up': ((0, 1), (29, 1)),            'walk_right': ((0, 2), (29, 2)),            'walk_left': ((0, 3), (29, 3)),            'walk_down': ((0, 0), (29, 0)),        })        self.player_parts = [self,self.right_det, self.left_det, self.up_det, self.down_det, self.player_graphics]    def update(self):        global movespeed, state, energy_core_action_enabled        if state == 'ingame' and paused == False and player.builder_mode == False:            right_hit = self.right_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            left_hit = self.left_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            up_hit = self.up_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            down_hit = self.down_det.intersects(debug=False, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            # ----------------------------------------------------------------------------------------------------------            # ------------------------------------------------------------------------------------------------------------------------------            if not held_keys['right mouse']:                if not shoot and held_keys['shift']:                    if player.player_stats['energy_core'] >= 1:                        movespeed = 4                        if energy_core_action_enabled == True:                            if held_keys['w'] or held_keys['a'] or held_keys['s'] or held_keys['d']:                                invoke(player_energy_core_action, -2, 'reduce', delay = 0.6)                                energy_core_action_enabled = False                else:                    movespeed = 2.5            # [] ---------------------------------------------------------------------------------------------------------------------------            if right_hit.hit == False:                for parts in self.player_parts:                    parts.x += held_keys['d'] * movespeed * time.dt            else: collison_hit()            if left_hit.hit == False:                for parts in self.player_parts:                    parts.x -= held_keys['a'] * movespeed * time.dt            else: collison_hit()            if up_hit.hit == False:                for parts in self.player_parts:                    parts.y += held_keys['w'] * movespeed * time.dt            else: collison_hit()            if down_hit.hit == False:                for parts in self.player_parts:                    parts.y -= held_keys['s'] * movespeed * time.dt            else: collison_hit()    # --------------------------------------------------------------------------------------------------------------    # A FŐ KARAKTER SÉTÁLÁSÁNAK ANIMÁLÁSA    def input(self, key):        if state == 'ingame' and paused == False and player.builder_mode == False:            if key == 'w':                self.directions[0] = 'up'                self.player_graphics.play_animation('walk_up')            elif key == 's':                self.directions[2] = 'down'                self.player_graphics.play_animation('walk_down')            elif key == 'a':                self.directions[1] = 'left'                self.player_graphics.play_animation('walk_left')            elif key == 'd':                self.directions[3] = 'right'                self.player_graphics.play_animation('walk_right')            # --------------------------------------------------------------------------------------------------------------            if key == 's up':                                                               # ha [s] felenged                self.directions[2] = 'no_down'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_down')            if key == 'a up':  # ha [a] felenged                self.directions[1] = 'no_left'                if self.directions[2] == 'down' : #                                         de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[0] == 'up' :                                           # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_left')            if key == 'd up': # ha [d] felenged                self.directions[3] = 'no_right'                if self.directions[0] == 'up' :                                             # de [w] még nyomva van                    self.player_graphics.play_animation('walk_up')                elif self.directions[1] == 'left' :                                         # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[2] == 'no_down' and self.directions[0] == 'no_up':     # ha [s] és [w] fel van engedve                    self.player_graphics.play_animation('idle_right')            if key == 'w up': # ha [w] felenged                self.directions[0] = 'no_up'                if self.directions[1] == 'left' :                                           # de [a] még nyomva van                    self.player_graphics.play_animation('walk_left')                elif self.directions[3] == 'right' :                                        # de [d] még nyomva van                    self.player_graphics.play_animation('walk_right')                elif self.directions[2] == 'down' :                                         # de [s] még nyomva van                    self.player_graphics.play_animation('walk_down')                elif self.directions[1] == 'no_left' and self.directions[3] == 'no_right':  # ha [a] és [d] fel van engedve                    self.player_graphics.play_animation('idle_up')######################################################################################################################## [ Place Class ] ###################################################################################################towers = [] # tartalmazza az összes tornyotclass Tower(Entity): # torony    def __init__(self, tag, x, y, hp, let_shoot, target, unbreakable, brokable_with, **kwargs):        global towers        super().__init__(self, **kwargs)        self.global_time = 0        self.last_time = 0        self.x = x        self.y = y        self.model = 'quad'        self.color = color.violet        self.position = (self.x, self.y, 0)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.scale = (3, 3, 0)        self.hp = hp        self.target = target # ellenség vagy a játékos a cél        self.let_shoot = let_shoot # lőhet-e, ez tornyok esetében jelentős        self.unbreakable = unbreakable # törhetetlen-e vagy sem - True / False        self.brokable_with = brokable_with # kitörhető valamilyen tárggyal a kézben, ez egy list is lehet.        self.shoot_cooldown = True        self.tower_bullets = []  # tartalmazza a kilőtt golyókat        towers.append(self)    def update(self):        global state        if state == 'ingame' and paused == False and player.builder_mode == False:            if self.let_shoot == True:                self.global_time += time.dt                if self.global_time - self.last_time > (randint(100, 150) / 100):  # random időközönként ad engedélyt                    self.last_time = self.global_time                    self.shoot_cooldown = True                for enemy in enemies:                    if enemy.alive:                        if distance([enemy.x, enemy.y, 0],[self.x, self.y, 0]) <= 15:                            if self.shoot_cooldown == True:                                tower_bullet = Entity(parent = scene, model = 'sphere',                                                      color = color.red, position = self.world_position, tag = 'tower_bullet',                                                      scale = (0.2, 0.2, 0.05))                                self.tower_bullets.append(tower_bullet)                                if self.target == 'enemy':                                    tower_bullet.look_at_2d(Vec3(enemy.world_position))                            self.shoot_cooldown = False                    #[] -----------------\\\///-------[]                    for bullet in self.tower_bullets:                        if enemy.alive == True:                            if distance(enemy, bullet) <= 1:                                self.tower_bullets.remove(bullet)                                destroy(bullet)                                enemy.color = color.black                                enemy.alive = False                                enemy.collider = None                                print('torony ellenségett lőtt')                        elif distance(enemy, bullet) > 20:                            destroy(bullet)                            self.tower_bullets.remove(bullet)                for bullet in self.tower_bullets:                    bullet.world_position += bullet.up * 85 * time.dt                    bullet_det = bullet.intersects(debug = False, ignore = (bullet))######################################################################################################################## [ SPAWNER Class ] ###################################################################################################raider_sheet = 'textures/enemy/raider/raider.png'enemies = [] # tartalmazza az összes létező ellenségetclass Spawner(Entity): # includes enemies ; npc-s    def __init__(self, tag, x, y, hp, list, let_shoot, let_move, invincible, **kwargs):        global enemies        super().__init__(self, **kwargs)        self.global_time = 0  #        self.last_time = 0        self.global_time_reload = 0  #        self.last_time_reload = 0        self.x = x        self.y = y        self.model = 'quad'        self.scale = (0.55,0.38,0)        self.position = (self.x, self.y, 0)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'box'        self.alpha = 0        enemies.append(self)        ##################################################x        self.body_texture = Entity(texture = raider_sheet, model = 'quad', position = (self.x, self.y, -0.1), scale = (1.65,1.14,0), alpha = 1)        # A lista tartalmazza az enemy layerjeit.        self.texture_list = [self, self.body_texture]        ##################################################x        self.list = list # a lista, amiben mozoghat        self.current_move = 0 # a jelenlegi állása a listában        self.invincible = invincible        self.alive = True        self.hp = hp        self.reload_enable = False # engedély újratöltésre - True ha üres a tár.        self.reloaded = False # Újratöltés befejezve. < késleltetve >        self.shot_bullet = [] # tartalmazza a kilőtt golyókat        self.shoot_directed = False  # True, ha a golyó kapott irányt.        self.shoot_delayed = False        self.full_ammo = 30        self.loaded_ammo = 8        self.now_you_see_me = False # True ha a játékos a látóterében van, és nem takarja semmilyen fal.        self.let_shoot = let_shoot        self.scale = (1, 1, 0)        self.let_move = let_move    # []//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]    def update(self):        global state        if state == 'ingame' and paused == False and player.builder_mode == False:            self.global_time += time.dt            if self.global_time - self.last_time > (randint(100,200) / 100):  # random időközönként ad engedélyt                self.last_time = self.global_time                self.shoot_delayed = True            if self.full_ammo != 0:                if self.reload_enable == True:                    self.global_time_reload += time.dt                    self.reload_enable = False                    if self.global_time_reload - self.last_time_reload > 3:  # random időközönként ad engedélyt                        self.last_time_reload = self.global_time_reload                        self.shoot_delayed_reload = True                        self.reloaded = True            #[]//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]            if self.alive:                if self.let_move == True:                    try:                        self.look_at_2d(Vec3(self.list[self.current_move][0],self.list[self.current_move][1],self.list[self.current_move][2]))                    except: pass                    if distance(self, player) >= 2:                        if self.current_move != len(self.list): # amíg a current_move nem egyenlő a lista hosszával                            for part in self.texture_list: # Végigjárja a listát, ami tartalmazza az enemy layerjeit.                                part.position += self.up * 0.02 # mozgatás                            if self.current_move != len(self.list) - 1:                                if round(self.position.x, 1) == round(float(self.list[self.current_move][0]),1): # ellenőrzi hogy elérte e a pozíciót.                                    if round(self.position.y, 1) == round(float(self.list[self.current_move][1]),1):                                        self.current_move += 1 # tovább lép a következő pontra.              #[]------------------------------------------------------------------------------------------------------------[]                # az ellenségek lövése és köztes akadályok ellenőrzése #####################################                if self.let_shoot == True: # ha az adott enemy számára a lövés engedélyezve van.                    if distance((self.x,0,0), (self.x,0,0)) <= 17.5 and distance((0,self.y,0), (0,self.y,0)) <= 11:  # lőtávolság                        obstacle_test = raycast(self.world_position,                                                direction = player.world_position - self.world_position,                                                distance = distance(player.world_position, self), traverse_target = scene, ignore = [self], debug = False)                        if obstacle_test.hit: # felsorolt elemeken keresztül nem lőhet rád az enemy                            if obstacle_test.entity.tag == 'enemy' or obstacle_test.entity.tag == 'building' or obstacle_test.entity.tag == 'tower':                                self.now_you_see_me = False                            else:                                self.now_you_see_me = True                    else:                        self.now_you_see_me = False                    if self.now_you_see_me == True: # ha az enemy látja a játékost.                        if self.loaded_ammo != 0:                            if self.shoot_delayed == True:                                self.shoot_delayed = False                                enemy_bullet = Entity(parent=scene, model='sphere', collider='box',                                                      color=color.red, position = self.world_position, tag = 'enemy_bullet', scale = (0.2, 0.2, 0.05))                                enemy_bullet.look_at_2d(Vec3(player.world_position))                                self.shot_bullet.append(enemy_bullet)                                self.loaded_ammo -= 1                                #print(self.loaded_ammo)                        if self.loaded_ammo == 0:                            self.reload_enable = True # Várnia kell 3 másodpercet míg újratölt                            if self.full_ammo != 0:                                a = 8                                if self.full_ammo < 8: # ha kevesebb mint 8 tölténye maradt, akkor csak annyit tölthessen vissza.                                    a = self.full_ammo                                if self.reloaded == True:                                    for i in range(a - self.loaded_ammo):                                        if self.full_ammo > 0:                                            self.full_ammo -= 1                                            self.loaded_ammo += 1  # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                                    #print('ammo:',self.full_ammo)            #[]--------------------------------------------------------------------------------------------------------[]            for bullet in self.shot_bullet:                bullet.world_position += bullet.up * 80 * time.dt  # a hányados takarja a sebességét a golyónak                if distance(player, bullet) <= 1:                    self.shot_bullet.remove(bullet)                    player_got_shot()                    destroy(bullet)                elif distance(player, bullet) > 20:                    self.shot_bullet.remove(bullet)                    destroy(bullet)# []-----------------------------------------------------------------------------------------------------------------[]#____________________________________________________________________________________________________________________## [ CONSTANTS ] ######################################################################################################wawe_movements = [ [13,2,0],[15,2,2],[15,2,0] ,[16,2,0],[17,2,5],[17,3,0],[18,3,10],[18,4,0],[21,4,0],[15,4,0] ], \                 [ [-13,-2,0],[-14,-2,0],[-15,-2,0],[-16,-2,0],[-17,-2,0],[-17,-3,0],[-18,-3,0],[-18,-4,0],[-19,-5,0] ], \                 [ [10,1,0] , [8,2,0] , [12,4,0]]test_movement = [[0,0,0] , [0,2,0], [8,6,0], [10,5,0]]#                   tag   x   y  hp  | move-list  |  let_shoot|let_move| invincible'''enemy01 = Spawner('enemy',1, 2, 50, test_movement    , True, True, False )enemy02 = Spawner('enemy',5, -2, 50, test_movement, True , True, False )enemy03 = Spawner('enemy',9, -2, 50, wawe_movements[2], True , True, False )enemy04 = Spawner('enemy',12, -2, 50, wawe_movements[1], True, True, False )enemy05 = Spawner('enemy',15, -2, 50, wawe_movements[0], True, True, False )enemy06 = Spawner('enemy',18, -2, 50, wawe_movements[0], True, True, False )enemy07 = Spawner('enemy',20, -2, 50, wawe_movements[1], True, True, False )enemy08 = Spawner('enemy',22, -2, 50, wawe_movements[2], True, True, False )enemy09 = Spawner('enemy',2.3, 0, 50, wawe_movements[2], True, True, False )enemy10 = Spawner('enemy',50, -2, 50, wawe_movements[1], True, True, False )enemy11 = Spawner('enemy',90, -2, 50, wawe_movements[0], True, True, False )enemy12 = Spawner('enemy',30, -2, 50, wawe_movements[1], True, True, False )enemy13 = Spawner('enemy',40, -2, 50, wawe_movements[0], True, True, False )enemy14 = Spawner('enemy',23, -2, 50, wawe_movements[0], True, True, False )enemy15 = Spawner('enemy',29, -2, 50, wawe_movements[1], True, True, False )enemy16 = Spawner('enemy',70, -2, 50, wawe_movements[2], True, True, False )enemy17 = Spawner('enemy',50,  0, 50, wawe_movements[2], True, True, False )enemy18 = Spawner('enemy',5 , -2, 50, wawe_movements[1], True, True, False )enemy19 = Spawner('enemy',9 , -2, 50, wawe_movements[0], True, True, False )enemy20 = Spawner('enemy',12, -2, 50, wawe_movements[1], True, True, False )enemy21 = Spawner('enemy',15, -20, 50,wawe_movements[0], True, True, False )enemy22 = Spawner('enemy',18, -20, 50,wawe_movements[0], True, True, False )enemy23 = Spawner('enemy',20, -2, 50, wawe_movements[1], True, True, False )enemy24 = Spawner('enemy',22, -20, 50,wawe_movements[2], True, True, False )'''#tower01 = Tower(tag = 'tower', x = 10,y = 10, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower02 = Tower(tag = 'tower', x = 5, y = 8,  hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])#tower03 = Tower(tag = 'tower', x = 13,y = -3, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])################################################################################################################################################################################################################################################full_ammo = 500 # bulletrevolver_ammo = 6 # bulletrevolver_shoot_speed = 0.2 # secpull_up = Trueshoot = Falsedef pull_up_delay():    global pull_up    if pull_up == False:        pull_up = True# [] ------------------------------------------------------------------------------------------------------------------[]def enemy_shot():    #ray.entity.disable() ---- del enemies[enemies.index(ray.entity)] #törli az adott entityt a listából    if not ray.entity.invincible:        ray.entity.alive = True        ray.entity.color = color.red# [] ------------------------------------------------------------------------------------------------------------------[]def player_got_shot(): # Meglőtték a játékost    global elapsed_time_player_got_shot    if player.invincibility == False:        player_health_core_action(randint(1,5), 'reduce')        elapsed_time_player_got_shot = 0# [] ------------ []def relocate(entity, x, y): # A* movement    grid = Grid(matrix=matrix.matrix)    start = grid.node(int(entity.x), int(entity.y))    end = grid.node(x, y)    finder = AStarFinder()    path, runs = finder.find_path(start, end, grid)    list_path = []    for i in range(len(path)):        list_path.append([path[i][0], path[i][1],0])    return list_path# [] ------------------------------------------------------------------------------------------------------------------[]pmenu_open = Falseweapon_wheel_open = Falselock_pausemenu = Falselock_swing_axe = Falsedef enable_pausemenu():    global lock_pausemenu    lock_pausemenu = Falsedef enable_swing_axe():    global lock_swing_axe    lock_swing_axe = False#----------------------------------#paused = Falsedef input(key):    global state, paused, lock_pausemenu, weapon_wheel_open, lock_swing_axe, follow_script    if state == 'ingame' and weapon_wheel_open == False and paused == False:        if player.alive == True:            if key == 'left mouse down':                pass #enemy01.list = relocate(enemy01, 5, 5)            global pull_up, revolver_ammo, full_ammo, bullet, ray, pmenu_open            if player.right_hand == 'colt':                if key == 'left mouse down':                    if pull_up == True and revolver_ammo > 0:                        if mouse.world_point:                            if shoot == True: # Ha a karakter céloz, mikozbe lő                                direction = mouse.world_point.x, mouse.world_point.y, 0                            if shoot == False: # Ha a karakter nem céloz - eredmény hogy nagyobb a szóras                                direction = mouse.world_point.x + (randint(-300, 300) / 100), mouse.world_point.y + (randint(-500, 500) / 100), 0                            bullet = Entity(parent = scene, model = 'sphere', color = color.black, position = player.position, tag ='projectile', scale = (0.2, 0.2, 0.2))                            bullet.look_at_2d(Vec3(direction))                            player.shot_bullet_list.append(bullet)                            pull_up = False                            revolver_ammo -= 1                            invoke(pull_up_delay, delay = revolver_shoot_speed)            # -------------------------------------------------------------------------                if key == 'r': # reload                    for i in range(6 - revolver_ammo):                        if full_ammo > 0:                            full_ammo -= 1                            revolver_ammo += 1 # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                if player.inventory_open == False:                    hud.show_ammo_text(revolver_ammo, full_ammo)            # ----------------------------------------------------------------------------------------------------------            # CUTTING THE TREES            if player.right_hand == 'axe':                if lock_swing_axe == False:                    if key == 'left mouse down':                        for tree in trees_list:                            if distance(player.position, tree.pos) <= 2:                                if tree.mouse_on == True and tree.health >= 1 and tree.cut == True:                                    tree.tree_stump.shake(duration=0.5, magnitude=0.5, speed=.05, direction=(0.6,0.2))                                    tree.tree_crown.shake(duration=0.5, magnitude=1.5, speed=.05, direction=(0.6, 0.2))                                    tree.health -= 1                        lock_swing_axe = True                        player.player_stats['energy'] -= 2                        player.player_stats['hunger'] -= 1                        player.player_stats['thirst'] -= 1                        invoke(enable_swing_axe, delay = 1)            # ----------------------------------------------------------------------------------------------------------    if state == 'inmenu':        if key == 'escape':            menu.back()    # ------------------------------------------------    if state == 'ingame' or paused == True:        if player.alive == True:            if key == 'escape':                if lock_pausemenu == False:                    if pmenu_open == False:                        pause_menu.show_menu()                        pmenu_open = True                        paused = True                        pause_menu.anim_clock(gametime_mins, gametime_hrs) # synching clock                        inventory.hide_inventory()                        player.inventory_open = False                        hud.hide_money_text()                    elif pmenu_open == True:                        pause_menu.close_menu(state)                        pmenu_open = False                        paused = False                    lock_pausemenu = True                    invoke(enable_pausemenu, delay = 0.6)    if state == 'ingame' and paused == False:        if player.alive == True:            if player.builder_mode == False:                if key == 'tab': # weapon wheelt kinyitja                    hud_weaponwheel.show_weaponwheel()                    weapon_wheel_open = True                if key == 'tab up': # weapon wheelt bezárja                    hud_weaponwheel.hide_weaponwheel()                    hud_weaponwheel.wheelbar_selector.fade_in(value=0, duration=0.15, delay = 0)                    weapon_wheel_open = False                    # WEAPON WHEEL TILES                    if hud_weaponwheel.get_back_selected_wheeltile() == 'right': # Ha a weapon wheel 'right' mezője aktív                        player.right_hand = 'hand'                        hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                        hud_weaponwheel.tile_selected.scale = (-0.25, -0.3, 0)                        hud_weaponwheel.tile_selected.position = (0.202, -0.021, -0.1)                        hud.hide_ammo_text()                # //////////////////////////////////////////////////////////////////////////////////////////////////////                if hud_weaponwheel.get_back_selected_wheeltile() == 'upper_left': # Ha a weapon wheel 'upper_left' mezője aktív                    player.right_hand = 'colt'                    hud_weaponwheel.tile_selected.rotation = (0, 0, 53)                    hud_weaponwheel.tile_selected.scale = (0.26, 0.31, 0)                    hud_weaponwheel.tile_selected.position = (-0.125, 0.125, -0.1)                    hud.show_ammo_text(revolver_ammo, full_ammo)                # //////////////////////////////////////////////////////////////////////////////////////////////////////                if hud_weaponwheel.get_back_selected_wheeltile() == 'left': # Ha a weapon wheel 'left' mezője aktív                    player.right_hand = 'axe' # vagy majda lámpás                    hud_weaponwheel.tile_selected.rotation = (0, 0, 0)                    hud_weaponwheel.tile_selected.scale = (0.25, 0.3, 0)                    hud_weaponwheel.tile_selected.position = (-0.195, -0.033, -0.1)                    hud.show_ammo_text(revolver_ammo, full_ammo)            # //////////////////////////////////////////////////////////////////////////////////////////////////////            # BUILDER MODE            if key == 'c':                if player.builder_mode == True:                    builder_mode.close_builder_mode()                    hud.show_hud()                    follow_script = camera.add_script(SmoothFollow(target=player, offset=[0, 1, -80], speed=4))                    player.builder_mode = False                elif player.builder_mode == False:                    builder_mode.open_builder_mode()                    hud.hide_hud()                    camera.scripts.remove(follow_script)                    player.builder_mode = True            if player.builder_mode == True:                if key == 'left mouse down':                    if mouse.world_point:                        print(floor(mouse.world_point.x), floor(mouse.world_point.y))            # ----------------------------------------------------------------------------------------------------------            # INVENTORY            if key == 'b' and player.builder_mode == False:                if player.inventory_open: # CLOSE INVENTORY                    inventory.hide_inventory()                    player.inventory_open = False                    hud.hide_money_text()                    if player.right_hand == 'colt':                        hud.show_ammo_text(revolver_ammo, full_ammo)                elif not player.inventory_open: # OPEN INVENTORY                    inventory.show_inventory()                    player.inventory_open = True                    hud.hide_ammo_text()                    hud.show_money_text(player.player_stats['bank_balance'],player.player_stats['wallet_balance'])######################################################################################################################### CORE ACTIONS #-------------------------------------------------------------------------------------------------------#hunger_core_action_enabled = Truethirst_core_action_enabled = Trueenergy_core_action_enabled = Truehealth_core_action_enabled = Truedef player_energy_core_action(energy, status):    global energy_core_action_enabled    if player.player_stats['energy'] > 0 and player.player_stats['energy'] <= 100:        player.player_stats['energy'] += energy    if status == 'reduce':        if player.player_stats['energy'] <= 0:            if player.player_stats['energy_core'] > 1:                player.player_stats['energy_core'] -= 1    energy_core_action_enabled = True# ____________________________________________def player_health_core_action(hp, status):    global health_core_action_enabled    if status == 'reduce':        if player.player_stats['health'] > 0:            player.player_stats['health'] -= hp        if player.player_stats['health'] <= 0:            if player.player_stats['health_core'] > 0:                player.player_stats['health_core'] -= 10    if status == 'increase': # növeli az életerőt        if elapsed_time_player_got_shot >= 5:            if player.player_stats['thirst_core'] >= 15 and player.player_stats['hunger_core'] >= 25:                if player.player_stats['health_core'] > 35 and player.player_stats['health_core'] < 100:                    player.player_stats['health'] += hp        health_core_action_enabled = True# ____________________________________________def player_thirst_core_action():    global thirst_core_action_enabled    if player.player_stats['thirst'] > 0:        player.player_stats['thirst'] -= randint(0,2)    if player.player_stats['thirst'] == 0:        if player.player_stats['thirst_core'] > 0:            player.player_stats['thirst_core'] -= randint(0, 2)    if player.player_stats['thirst_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    thirst_core_action_enabled = True# ____________________________________________def player_hunger_core_action():    global hunger_core_action_enabled    if player.player_stats['hunger'] > 0:        player.player_stats['hunger'] -= randint(0,2)    if player.player_stats['hunger'] == 0:        if player.player_stats['hunger_core'] > 0:            player.player_stats['hunger_core'] -= randint(0, 2)    if player.player_stats['hunger_core'] <= 0:        player_health_core_action(randint(0,2), 'reduce')    hunger_core_action_enabled = True#########################################################################################################################----------------------------------------------------------------------------------------------------------------------#time_globaled = 0last_gametime = 0gametime_all = 0 # 'ingame' töltött játékidőgametime_hrs = 6 # meghatározza a kezdeti időt órákban.gametime_mins = 0 # meghatározza a kezdeti időt percekben.elapsed_time_player_got_shot = 0anim_test = Truedef doit():    global anim_test    anim_test = Truedef hide_tree_crown(tree):    destroy(tree.tree_crown, delay = 3)    tree.tree_crown.shake(duration=0.5, magnitude=1, speed=.05, direction=(1, 0.5))    tree.tree_crown.fade_in(value=0, duration=1.5, delay=1.5)def update():    global shoot, paused, movespeed, state, time_globaled, last_gametime, gametime_hrs, gametime_mins, gametime_all, anim_test    global thirst_core_action_enabled, health_core_action_enabled, hunger_core_action_enabled, energy_core_action_enabled    global elapsed_time_player_got_shot    state = get_status() # get value from menu    if state == 'ingame' and paused == False and player.builder_mode == False:        # --------------------------------------------------------------------        # CORE SAFETY        cores_list = [['health','health_core'],['thirst','thirst_core'],['power','power_core'],['hunger','hunger_core'],['energy','energy_core']]        for core in cores_list:            if player.player_stats[core[0]] < 0:                player.player_stats[core[0]] = 0            if player.player_stats[core[0]] > 100:                player.player_stats[core[0]] = 100            if player.player_stats[core[1]] < 0:                player.player_stats[core[1]] = 0            if player.player_stats[core[1]] > 50:                player.player_stats[core[1]] = 50        # [ PLAYER DEAD ] ----------------------------------------------------------------------------------------------        if player.player_stats['health_core'] <= 0 and player.alive == True:            player.alive = False            hud.show_death_screen()            print('dead')        if hud.dead_screen_status == 'respawned': # respawned / none            player.alive = True            hud.dead_screen_status = 'none'            player.player_stats['health_core'] = 25            player.player_stats['health'] = 25            player.player_stats['energy'] = 25            player.player_stats['energy_core'] = 25            player.player_stats['hunger'] = 25            player.player_stats['hunger_core'] = 12            player.player_stats['thirst'] = 35            player.player_stats['thirst_core'] = 12            player.player_stats['power'] = 0            player.player_stats['power_core'] = 0        # [ INGAME TIME ] ----------------------------------------------------------------------------------------------------------[]        # THEORY        # Minden egyes valós másodperc a játékban egy percnek felel meg        # Ennek tudatában egy játékbeli nap 24 valós percből áll.        # A játékos 6-kor kel, és legkésőbb hajnali 2-re ágyba kell bújnia. Így a játékidő egy játékbeli napra legfeljebb 20 percet jelent.        time_globaled += time.dt        elapsed_time_player_got_shot += time.dt        if time_globaled - last_gametime > 1:  # 1 másodpercenként tickel            last_gametime = time_globaled            gametime_all += 1            if gametime_hrs != 2:                gametime_mins += 1                if gametime_mins % 60 == 0:                    gametime_hrs += 1                    gametime_mins = 0                if gametime_hrs % 24 == 0:                    gametime_hrs = 0                #print(f'{gametime_hrs}:{gametime_mins}')                env_light.time_set(gametime_mins + (gametime_hrs * 60))            if hunger_core_action_enabled == True:                invoke(player_hunger_core_action, delay = (randint(40,100) / 10))                hunger_core_action_enabled = False            if thirst_core_action_enabled == True:                invoke(player_thirst_core_action, delay = (randint(40,100) / 10))                thirst_core_action_enabled = False            if health_core_action_enabled == True:                invoke(player_health_core_action, 1, 'increase', delay = 1)                health_core_action_enabled = False            if energy_core_action_enabled == True:                invoke(player_energy_core_action, randint(1, 2), 'increase', delay=(randint(10, 40) / 10))                energy_core_action_enabled = False        # [] ----------------------------------------------------------------------------------------------------------[]        # A játék információt küld a HUD-nak a játékos statisztikáiról.        # player.player_stats['health'] = 123        hud.anim_cores(player.player_stats)        '''if anim_test == True:            player.player_stats['health_core'] -= 1            player.player_stats['health'] -= 1            player.player_stats['energy_core'] -= 1            player.player_stats['energy'] -= 1            player.player_stats['power_core'] -= 1            player.player_stats['power'] -= 1            player.player_stats['hunger_core'] -= 1            player.player_stats['hunger'] -= 1            player.player_stats['thirst_core'] -= 1            player.player_stats['thirst'] -= 1            hud.anim_cores(player.player_stats)            anim_test = False            invoke(doit, delay = 0.02)'''        # [] ----------------------------------------------------------------------------------------------------------[]        # Célzás közben a játékos legyen lassabb.        if held_keys['right mouse']:            shoot = True            movespeed = 1        else:            shoot = False        # ------------------------------------        for shot_bullet in player.shot_bullet_list:            shot_bullet.world_position += shot_bullet.up * 85 * time.dt            for enemy in enemies:                if enemy.alive == True:                    if distance(enemy.world_position, shot_bullet.world_position) <= 1:                        enemy.alive = False                        enemy.color = color.black                        enemy.collider = None                        shot_bullet.disable()            bullet_det = shot_bullet.intersects(debug = True, ignore = (shot_bullet))            if bullet_det.hit == True:                print('eltaláltam valamit')        ################################################################################################################################        # TREE HANDLING        for tree in trees_list:            if distance(tree.pos, player.position) <= 12:                if player.position.y >= tree.pos[1]:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.front_layer)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.front_layer)                else:                    tree.tree_stump.position = Vec3(tree.tree_stump.position.x, tree.tree_stump.position.y, tree.back_layer)                    if tree.tree_crown:                        tree.tree_crown.position = Vec3(tree.tree_crown.position.x, tree.tree_crown.position.y, tree.back_layer)                    # //////////////////////////////////////////////////////////////////////////////////////////////////                if tree.alive:                    if player.position.y >= tree.pos[1] + 1 and player.position.y <= tree.pos[1] + 10:                        if player.position.x >= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 0.8                            tree.tree_crown.alpha = 0.8                        if player.position.x >= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                        if player.position.x <= tree.pos[0] + 1.5:                            tree.tree_stump.alpha = 0.8                            tree.tree_crown.alpha = 0.8                        if player.position.x <= tree.pos[0] - 1.5:                            tree.tree_stump.alpha = 1                            tree.tree_crown.alpha = 1                    else:                        tree.tree_stump.alpha = 1                        tree.tree_crown.alpha = 1                ########################################################################################################                # CUT THE TREES                if tree.alive == True and tree.health == 0:                    tree.alive = False                    if player.x >= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,-90), duration = 2.2, curve = curve.in_quart)                    if player.x <= tree.pos[0]:                        tree.tree_crown.animate_rotation((0,0,90), duration = 2.2, curve = curve.in_quart)                    invoke(hide_tree_crown, tree,  delay = 2)    ################################################################################################################################    # BUILDER MODE    if state == 'ingame' and player.builder_mode == True:        if held_keys['left mouse']:            camera.x -= mouse.velocity[0] * 30            camera.y -= mouse.velocity[1] * 30        camera.x -= held_keys['a'] * time.dt * 25        camera.x += held_keys['d'] * time.dt * 25        camera.y -= held_keys['s'] * time.dt * 25        camera.y += held_keys['w'] * time.dt * 25        if mouse.world_point:            builder_mode.update_grid(floor(mouse.world_point.x), floor(mouse.world_point.y))########################################################################################################################## [ THREADING ][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]'''def thrd():    while True:        passthread = Thread(target = thrd)thread.setDaemon(True)thread.start()'''######################################################################################################################### [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]# -----------------------------------------------------------*# CLASS-ok meghívása# a Z tengely alapból -0.15player = Player(x = 0, y = 0, invincibility = False)# --------hud = HUD(language_pack, player.player_stats)menu = Menu(language_pack, hud)pause_menu = PauseMenu(language_pack, menu, hud, player)hud_weaponwheel = WeaponWheel(language_pack, pause_menu)env_light = LightSystem()inventory = Inventory(pause_menu)inventory.add_item(_item_ = 'bag', category = 'treasure')inventory.add_item(_item_ = 'gem', category = 'treasure')builder_mode = BuilderModeHud()# -----------------------------------------------------------*menu.show_menu()bg = 'main_tile1.png'world_canvas = Entity(origin = (-0.5, -0.5, 0), model = 'quad', collider = 'box', scale = (192,108,0), position = (0,0,.1), tag = 'canvas')follow_script = camera.add_script(SmoothFollow(target = player, offset=[0, 1, -80], speed = 4))object1 = Entity(model='cube', collider='mesh', scale=(3,5,0), color = color.green, position = (-7,2,0), tag = 'building')# ----------------------------------------------------------------------------------------------------------------------*#Environmenttree1 = Trees(type = 'oak', stage = 4, position = [5, 2, -0.05], cut = True, matrix = matrix)tree2 = Trees(type = 'oak', stage = 4, position = [8, 5, -0.05], cut = True, matrix = matrix)tree3 = Trees(type = 'oak', stage = 4, position = [11, 2, -0.05], cut = True, matrix = matrix)tree4 = Trees(type = 'oak', stage = 4, position = [18, 8, -0.05], cut = True, matrix = matrix)trees_list = [tree1, tree2, tree3, tree4]# ----------------------------------------------------------------------------------------------------------------------*'''Cursor(texture = 'textures\misc\cursor\cursor.png', scale=.05)mouse.visible = False'''objects_list = [object1]app.run()