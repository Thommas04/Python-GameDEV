# REDNOTE PROJECT 2022 - KOP / SK# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #from ursina import *from ursina.raycaster import raycastfrom os import *from random import *from PIL import *from pathfinding.core.diagonal_movement import DiagonalMovementfrom pathfinding.core.grid import Gridfrom pathfinding.finder.a_star import AStarFinderfrom collisions import *from objects import *from functions import *from menu import Menufrom pause_menu import *from menu import *from hud import *# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #settings_file = fileread('settings/settings.rsp') # Megnyitni a settings fájlt.language = settings_file[0].split(':')[1] # kiolvasni a settings fájlból a beállított nyelvet.for file in os.listdir('./languages'):    exec('from languages.' + language + ' import *')    if file.endswith('.py'):        language_file = file.split('.')[0]        if language_file == language:            language_pack = set_language()# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ## [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #app = Ursina()window.color = rgb(16.065,32.895,28.05)place_all_objects()townlevel_collision()window.exit_button.enabled = Falseprint(settings_file[3].split(':')[1])if settings_file[3].split(':')[1] == "True":    window.fps_counter.x = 0.85    window.fps_counter.font = 'fonts/pricedown.otf'    window.fps_counter.color = rgb(255, 163, 57)    window.fps_counter.alpha = 0.6else:    window.fps_counter.disable()#EditorCamera()#create_net()#background = Entity(model = 'cube', collider = 'box', scale = (1000,1000,0), color = color.dark_gray, position = (0,0,0.1))# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## ingame / inmenustate = 'inmenu'# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] ## 2D MATRIX# minden elemének eleme egy lista, amelynek#               - első eleme : / szabad e az adott terület [ True / False ]#               - második eleme: / blokkok neve, melyhez tulajdonságokat társítunk. [ grass, path, stone, wood ]#               - harmadik eleme: /class Matrix:    def __init__(self, size_x, size_y):        self.matrix = [[1 for x in range(size_x)] for y in range(size_y)]    def get_value(self, state, x, y): # visszaadja az adott terület értékét        return self.grid[y][x][state]    def set_value(self, state, x, y, value): # adott területre értéket állít        self.grid[y][x][state] = value    def g_print(self): # printeli a mátrixot        for x in self.grid:            print(f'{x}')moveable_area = Matrix(size_x = 200, size_y = 200)# [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] #def collison_hit():    passclass Player(Entity):    def __init__(self, x, y,  **kwargs):        super().__init__(self, **kwargs)        self.model = 'plane'        self.color = color.orange        self.scale = (1, 1, -1)        self.rotation = (90, 0, 0)        self.position = [x, y, 0]        self.tag = 'player'        self.right_det = Entity(model='plane', scale=(0.1, 1, -1), position=(0.5, 0, 0), color=color.red, rotation=(90, 0, 0), collider='box', tag='collision', visible=True)        self.left_det = Entity(model='plane', scale=(0.1, 1, -1), position=(-0.5, 0, 0), color=color.brown, rotation=(90, 0, 0), collider='box', tag='collision', visible=True)        self.up_det = Entity(model='plane', scale=(1, 1, -0.1), position=(0, 0.5, 0), color=color.azure, rotation=(90, 0, 0), collider='box', tag='collision', visible=True)        self.down_det = Entity(model='plane', scale=(1, 1, -0.1), position=(0, -0.5, 0), color=color.pink, rotation=(90, 0, 0), collider='box', tag='collision', visible=True)        self.player_parts = [self, self.right_det, self.left_det, self.up_det, self.down_det]        self.shot_bullet_list = []    def update(self):        global movespeed, state        if state == 'ingame':            right_hit = self.right_det.intersects(debug=True, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            left_hit = self.left_det.intersects(debug=True, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            up_hit = self.up_det.intersects(debug=True, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            down_hit = self.down_det.intersects(debug=True, ignore=(self.right_det, self.left_det, self.up_det, self.down_det))            if shoot == False:                if held_keys['shift']:                    movespeed = 4                else:                    movespeed = 2.5            if right_hit.hit == False:                for parts in self.player_parts:                    parts.x += held_keys['d'] * movespeed * time.dt            else: collison_hit()            if left_hit.hit == False:                for parts in self.player_parts:                    parts.x -= held_keys['a'] * movespeed * time.dt            else: collison_hit()            if up_hit.hit == False:                for parts in self.player_parts:                    parts.y += held_keys['w'] * movespeed * time.dt            else: collison_hit()            if down_hit.hit == False:                for parts in self.player_parts:                    parts.y -= held_keys['s'] * movespeed * time.dt            else: collison_hit()######################################################################################################################## [ Place Class ] ###################################################################################################class Place(Entity): # torony    def __init__(self, tag, x, y, hp, let_shoot, target, unbreakable, brokable_with, **kwargs):        super().__init__(self, **kwargs)        self.global_time = 0        self.last_time = 0        self.x = x        self.y = y        self.model = 'cube'        self.color = color.violet        self.position = (self.x, self.y, 0)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'mesh'        self.scale = (3, 3, 0)        self.hp = hp        self.target = target # ellenség vagy a játékos a cél        self.let_shoot = let_shoot # lőhet-e, ez tornyok esetében jelentős        self.unbreakable = unbreakable # törhetetlen-e vagy sem - True / False        self.brokable_with = brokable_with # kitörhető valamilyen tárggyal a kézben, ez egy list is lehet.        self.shoot_cooldown = True        self.tower_bullets = []  # tartalmazza a kilőtt golyókat    def update(self):        global state        if state == 'ingame':            if self.let_shoot == True:                self.global_time += time.dt                if self.global_time - self.last_time > (randint(100, 150) / 100):  # random időközönként ad engedélyt                    self.last_time = self.global_time                    self.shoot_cooldown = True                for enemy in enemies:                    if enemy.alive:                        if distance([enemy.x, enemy.y, 0],[self.x, self.y, 0]) <= 15:                            if self.shoot_cooldown == True:                                tower_bullet = Entity(parent = scene, model = 'sphere',                                                      color = color.red, position = self.world_position, tag = 'tower_bullet',                                                      scale = (0.2, 0.2, 0.05))                                self.tower_bullets.append(tower_bullet)                                if self.target == 'enemy':                                    tower_bullet.look_at_2d(Vec3(enemy.world_position))                            self.shoot_cooldown = False                    #[] -----------------\\\///-------[]                    for bullet in self.tower_bullets:                        if enemy.alive == True:                            if distance(enemy, bullet) <= 1:                                self.tower_bullets.remove(bullet)                                destroy(bullet)                                enemy.color = color.black                                enemy.alive = False                                enemy.collider = None                                print('torony ellenségett lőtt')                        elif distance(enemy, bullet) > 20:                            destroy(bullet)                            self.tower_bullets.remove(bullet)                for bullet in self.tower_bullets:                    bullet.world_position += bullet.up * 85 * time.dt                    bullet_det = bullet.intersects(debug = False, ignore = (bullet))######################################################################################################################## [ SPAWNER Class ] ###################################################################################################class Spawner(Entity): # includes enemies ; npc-s ; towers ;    def __init__(self, tag, x, y, hp, list, let_shoot, let_move, invincible, **kwargs):        super().__init__(self, **kwargs)        self.global_time = 0  #        self.last_time = 0        self.global_time_reload = 0  #        self.last_time_reload = 0        self.x = x        self.y = y        self.model = 'cube'        self.color = color.red        self.position = (self.x, self.y, 0)        self.rotation = (0, 0, 0)        self.tag = tag        self.collider = 'mesh'        ##################################################x        self.list = list # a lista, amiben mozoghat        self.current_move = 0 # a jelenlegi állása a listában        self.invincible = invincible        self.alive = True        self.hp = hp        self.reload_enable = False # engedély újratöltésre - True ha üres a tár.        self.reloaded = False # Újratöltés befejezve. < késleltetve >        self.shot_bullet = [] # tartalmazza a kilőtt golyókat        self.shoot_directed = False  # True, ha a golyó kapott irányt.        self.shoot_delayed = False        self.full_ammo = 11        self.loaded_ammo = 8        self.now_you_see_me = False # True ha a játékos a látóterében van, és nem takarja semmilyen fal.        self.let_shoot = let_shoot        self.scale = (1, 1, 0)        self.let_move = let_move    # []//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]    def update(self):        global state        if state == 'ingame':            self.global_time += time.dt            if self.global_time - self.last_time > (randint(100,200) / 100):  # random időközönként ad engedélyt                self.last_time = self.global_time                self.shoot_delayed = True            if self.full_ammo != 0:                if self.reload_enable == True:                    self.global_time_reload += time.dt                    self.reload_enable = False                    if self.global_time_reload - self.last_time_reload > 3:  # random időközönként ad engedélyt                        self.last_time_reload = self.global_time_reload                        self.shoot_delayed_reload = True                        self.reloaded = True            #[]//////////////////////////////////////////////////////////////////////////////////////////////////////////////[]            if self.alive:                if self.let_move == True:                    try:                        self.look_at_2d(Vec3(self.list[self.current_move][0],self.list[self.current_move][1],self.list[self.current_move][2]))                    except: pass                    if distance(self, player) >= 2:                        if self.current_move != len(self.list): # amíg a current_move nem egyenlő a lista hosszával                            self.position += self.up * 0.02 # mozgatás                            if self.current_move != len(self.list) - 1:                                if round(self.position.x, 1) == round(float(self.list[self.current_move][0]),1): # ellenőrzi hogy elérte e a pozíciót.                                    if round(self.position.y, 1) == round(float(self.list[self.current_move][1]),1):                                        self.current_move += 1 # tovább lép a következő pontra.              #[]------------------------------------------------------------------------------------------------------------[]                # az ellenségek lövése és köztes akadályok ellenőrzése #####################################                if self.let_shoot == True: # ha az adott enemy számára a lövés engedélyezve van.                    if distance((self.x,0,0), (self.x,0,0)) <= 17.5 and distance((0,self.y,0), (0,self.y,0)) <= 11:  # lőtávolság                        obstacle_test = raycast(self.world_position,                                                direction = player.world_position - self.world_position,                                                distance = distance(player.world_position, self), traverse_target = scene, ignore = [self], debug = False)                        if obstacle_test.hit: # felsorolt elemeken keresztül nem lőhet rád az enemy                            if obstacle_test.entity.tag == 'enemy' or obstacle_test.entity.tag == 'building' or obstacle_test.entity.tag == 'tower':                                self.now_you_see_me = False                            else:                                self.now_you_see_me = True                    else:                        self.now_you_see_me = False                    if self.now_you_see_me == True: # ha az enemy látja a játékost.                        if self.loaded_ammo != 0:                            if self.shoot_delayed == True:                                self.shoot_delayed = False                                enemy_bullet = Entity(parent=scene, model='sphere', collider='box',                                                      color=color.red, position = self.world_position, tag = 'enemy_bullet', scale = (0.2, 0.2, 0.05))                                enemy_bullet.look_at_2d(Vec3(player.world_position))                                self.shot_bullet.append(enemy_bullet)                                self.loaded_ammo -= 1                                #print(self.loaded_ammo)                        if self.loaded_ammo == 0:                            self.reload_enable = True # Várnia kell 3 másodpercet míg újratölt                            if self.full_ammo != 0:                                a = 8                                if self.full_ammo < 8: # ha kevesebb mint 8 tölténye maradt, akkor csak annyit tölthessen vissza.                                    a = self.full_ammo                                if self.reloaded == True:                                    for i in range(a - self.loaded_ammo):                                        if self.full_ammo > 0:                                            self.full_ammo -= 1                                            self.loaded_ammo += 1  # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.                                    #print('ammo:',self.full_ammo)            #[]--------------------------------------------------------------------------------------------------------[]            for bullet in self.shot_bullet:                bullet.world_position += bullet.up * 80 * time.dt  # a hányados takarja a sebességét a golyónak                if distance(player, bullet) <= 1:                    self.shot_bullet.remove(bullet)                    player_got_shot()                    destroy(bullet)                elif distance(player, bullet) > 20:                    self.shot_bullet.remove(bullet)                    destroy(bullet)#____________________________________________________________________________________________________________________## [ CONSTANTS ] ######################################################################################################wawe_movements = [ [13,2,0],[15,2,2],[15,2,0] ,[16,2,0],[17,2,5],[17,3,0],[18,3,10],[18,4,0],[21,4,0],[15,4,0] ], \                 [ [-13,-2,0],[-14,-2,0],[-15,-2,0],[-16,-2,0],[-17,-2,0],[-17,-3,0],[-18,-3,0],[-18,-4,0],[-19,-5,0] ], \                 [ [10,1,0] , [8,2,0] , [12,4,0]]test_movement = [[0,0,0] , [0,2,0], [8,6,0], [10,5,0]]#                   tag   x   y  hp  | move-list  |  let_shoot|let_move| invincibleenemy01 = Spawner('enemy',1, 2, 50, test_movement    , True, True, False )enemy02 = Spawner('enemy',5, -2, 50, test_movement, True , True, False )enemy03 = Spawner('enemy',9, -2, 50, wawe_movements[2], True , True, False )enemy04 = Spawner('enemy',12, -2, 50, wawe_movements[1], True, True, False )enemy05 = Spawner('enemy',15, -2, 50, wawe_movements[0], True, True, False )enemy06 = Spawner('enemy',18, -2, 50, wawe_movements[0], True, True, False )enemy07 = Spawner('enemy',20, -2, 50, wawe_movements[1], True, True, False )enemy08 = Spawner('enemy',22, -2, 50, wawe_movements[2], True, True, False )enemy09 = Spawner('enemy',2.3, 0, 50, wawe_movements[2], True, True, False )enemy10 = Spawner('enemy',50, -2, 50, wawe_movements[1], True, True, False )enemy11 = Spawner('enemy',90, -2, 50, wawe_movements[0], True, True, False )enemy12 = Spawner('enemy',30, -2, 50, wawe_movements[1], True, True, False )enemy13 = Spawner('enemy',40, -2, 50, wawe_movements[0], True, True, False )enemy14 = Spawner('enemy',23, -2, 50, wawe_movements[0], True, True, False )enemy15 = Spawner('enemy',29, -2, 50, wawe_movements[1], True, True, False )enemy16 = Spawner('enemy',70, -2, 50, wawe_movements[2], True, True, False )enemy17 = Spawner('enemy',50,  0, 50, wawe_movements[2], True, True, False )enemy18 = Spawner('enemy',5 , -2, 50, wawe_movements[1], True, True, False )enemy19 = Spawner('enemy',9 , -2, 50, wawe_movements[0], True, True, False )enemy20 = Spawner('enemy',12, -2, 50, wawe_movements[1], True, True, False )enemy21 = Spawner('enemy',15, -20, 50,wawe_movements[0], True, True, False )enemy22 = Spawner('enemy',18, -20, 50,wawe_movements[0], True, True, False )enemy23 = Spawner('enemy',20, -2, 50, wawe_movements[1], True, True, False )enemy24 = Spawner('enemy',22, -20, 50,wawe_movements[2], True, True, False )enemies = [enemy01,enemy02,enemy03,enemy04,enemy05,enemy06,enemy07,enemy08,enemy09,enemy10,enemy11,enemy12,enemy13,enemy14,enemy15,enemy16,enemy17,enemy18,enemy19,enemy20,enemy21,enemy22,enemy23,enemy24]tower01 = Place(tag = 'tower', x = 10, y = 10, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])tower02 = Place(tag = 'tower', x = 5, y = 8, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])tower03 = Place(tag = 'tower', x = 13, y = -3, hp = 100, let_shoot = True, target = 'enemy', unbreakable = False, brokable_with = ['bullet','explosive'])towers = [tower01]#, tower02, tower03]################################################################################################################################################################################################################################################full_ammo = 500 # bulletrevolver_ammo = 10 # bulletrevolver_shoot_speed = 0.2 # secpull_up = Trueshoot = Falsedef pull_up_delay():    global pull_up    if pull_up == False:        pull_up = True# [] ------------------------------------------------------------------------------------------------------------------[]def enemy_shot():    #ray.entity.disable() ---- del enemies[enemies.index(ray.entity)] #törli az adott entityt a listából    if not ray.entity.invincible:        ray.entity.alive = True        ray.entity.color = color.red# [] ------------------------------------------------------------------------------------------------------------------[]def player_got_shot():    print('meglőttek')def relocate(entity, x, y): # A* movement    grid = Grid(matrix=moveable_area.matrix)    start = grid.node(int(entity.x), int(entity.y))    end = grid.node(x, y)    finder = AStarFinder()    path, runs = finder.find_path(start, end, grid)    list_path = []    for i in range(len(path)):        list_path.append([path[i][0], path[i][1],0])    return list_path# [] ------------------------------------------------------------------------------------------------------------------[]pmenu_open = Falselock_pausemenu = Falsedef enable_pausemenu():    global lock_pausemenu    lock_pausemenu = False#----------------------------------#def input(key):    global state, lock_pausemenu, lock_weaponwheel    if state == 'ingame':        if key == 'left mouse down':            pass #enemy01.list = relocate(enemy01, 5, 5)        global pull_up, revolver_ammo, full_ammo, bullet, ray, pmenu_open        if key == 'left mouse down':            if pull_up == True and revolver_ammo > 0:                if shoot == True: # Ha a karakter céloz, mikozbe lő                    direction = mouse.world_point.x, mouse.world_point.y, 0                if shoot == False: # Ha a karakter nem céloz - eredmény hogy nagyobb a szóras                    direction = mouse.world_point.x + (randint(-300, 300) / 100), mouse.world_point.y + (randint(-500, 500) / 100), 0                bullet = Entity(parent = scene, model = 'sphere', color = color.black, position = player.position, tag ='projectile', scale = (0.2, 0.2, 0.2))                bullet.look_at_2d(Vec3(direction))                player.shot_bullet_list.append(bullet)                pull_up = False                revolver_ammo -= 1                invoke(pull_up_delay, delay = revolver_shoot_speed)        if key == 'r': # reload            for i in range(10 - revolver_ammo):                if full_ammo > 0:                    full_ammo -= 1                    revolver_ammo += 1 # hangot lejátsza invoke-kal késleltetve, hozzáadott idővel.    if state == 'inmenu':        if key == 'escape':            menu.back()    if state == 'ingame' or state == 'paused':        if key == 'escape':            if lock_pausemenu == False:                if pmenu_open == False:                    pause_menu.show_menu()                    pmenu_open = True                    state = 'paused'                elif pmenu_open == True:                    pause_menu.close_menu()                    pmenu_open = False                    state = 'ingame'                lock_pausemenu = True                invoke(enable_pausemenu, delay = 1)    if state == 'ingame':        if key == 'left alt':            hud.show_weaponwheel()        if key == 'left alt up':            hud.hide_weaponwheel()########################################################################################################################def update():    global shoot, movespeed, state    if state == 'ingame' or state == 'inmenu':        state = get_status() # get value from menu    if state == 'ingame':        if held_keys['right mouse']:            shoot = True            movespeed = 1        else:            shoot = False        for shot_bullet in player.shot_bullet_list:            shot_bullet.world_position += shot_bullet.up * 85 * time.dt            for enemy in enemies:                if enemy.alive == True:                    if distance(enemy.world_position, shot_bullet.world_position) <= 1:                        enemy.alive = False                        enemy.color = color.black                        enemy.collider = None                        shot_bullet.disable()            bullet_det = shot_bullet.intersects(debug = True, ignore = (shot_bullet))            if bullet_det.hit == True:                print('eltaláltam valamit')######################################################################################################################### [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]menu = Menu(language_pack)pause_menu = PauseMenu(language_pack)hud = Hud(language_pack, pause_menu)menu.show_menu()player = Player(0,0)player.alpha = 0.5bg = 'main_tile1.png'L1 = AmbientLight(y = -2, z = 100, color = color.yellow, scale = 1000)#world_canvas = Entity(texture = bg, model = 'cube', collider = 'box', scale = (192,108,-0.05), position = (0,0,.1), tag = 'canvas')camera.add_script(SmoothFollow(target = player, offset=[0, 1, -50], speed = 4))object1 = Entity(model='cube', collider='mesh', scale=(3,5,0), color = color.red, position = (-7,2,0), tag = 'building')'''object = Entity(model='cube', collider='mesh', scale=(1,1,0), color = color.gray, x = -3, y = 3.6, tag = 'building')object = Entity(model='cube', collider='mesh', scale=(1,1,0), color = color.gray, x = -2.3, y = 0, tag = 'building')object = Entity(model='cube', collider='mesh', scale=(1,4,0), color = color.gray, x = -2, y = 0, tag = 'building')object = Entity(model='cube', collider='mesh', scale=(1,2,0), color = color.gray, x = -3, y = -1, tag = 'building')object = Entity(model='cube', collider='mesh', scale=(5,5,0), color = color.gray, x = 8, y = 2, tag = 'building')''''''Cursor(texture = 'textures\misc\cursor\cursor.png', scale=.05)mouse.visible = False'''objects_list = [object1]app.run()